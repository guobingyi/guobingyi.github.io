<!DOCTYPE html>
<html lang="zh-cn">

<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">
<meta name="author" content="Arthur Dent">
<meta name="description" content="You got to put the past behind you before you can move on.
 由于项目上的需要开始接触shell，其实shell早就有过接触，只不过这次接触了，深入的思考了。
0x00 为什么用shell? 原来学习一门语言的时候都会这样问自己？但是大多数的答案都是：项目上需要。没有思考的余地，也就没有深入的思考。
现在开始用到，也学习了python,ruby,swift,javascript后发现，shell有她自身更好的发挥余地。比如我们经常会使用的命令cd,hugo server,git add -A等。别小看这些命令，一个一个来，还是要输入一会的。程序员不就图个安逸，一个shell脚本搞定的事情，为什么要多来输入几次呢？在举个例子，如果终端只有一个，那么要看tomcat的日志，还要更新类，那么就会来回的路径下切换，如果不用文本记录下来，光敲路径就花费很长的时间，so，用个shell脚本就可以解决了。当然，这个例子也不能说明shell的强大之处，那么这个例子就是shell的重要用途了。在零部署的时候，需要安装一些组件，数据库，初始化数据库脚本，注册服务，启动服务，关机。整个流程可以说一气呵成，但是如果是人工的话，那么想想工作量也是吓人的，这还不包括部署多台服务器呢。
如果是安装系统，会非常喜欢ghost版本，安装就step by step。而shell就提供了这样功能。当然有人会说python也一样搞定。是的，不可否认，但是如果python自身也需要安装库呢？所以，shell独天得厚的优势在于系统自带的同时，还可以自动安装所需的命令。
结论就是：如果你需要将命令step by step执行，那么就选择shell吧。
0x01 Hello,World! 每个学习程序设计的开始都会是这个，也因为这个才从此入坑。
创建文件hello.sh,输入一下内容：
#!/bin/bash echo &#39;Hello.World!&#39;  在终端中使用sh hello.sh,将输出以下结果：
Hello,World!  恭喜你，入门了。
思考：
 为什么第一行会有个#!/bin/bash echo 可以用单引号，也可以用双引号，区别是什么？ 如果要让shell脚步可以直接运行，怎么做？ 如何文件后缀是php,那么有该如何做呢？  0x02 变量 shell的变量命令基本和常用语言(pythoh/ruby/java/go)基本差不多，目前还没有遇到过坑。
那么如何定义一个变量呢？ someone=&quot;Lee&quot; some_two=&quot;http://10.10.10.222&quot;  看似简单的定义变量，如果写多了程序，就会有个问题，如下：
someone = &quot;Lee&quot; #Eroor  为什么会有这个错误，因为写代码的时候都喜欢来个空格，这样看着顺眼些，但是在shell里是错误的。因为变量名和等号之间不能有空格。
变量名和等号之间不能有空格。
变量名和等号之间不能有空格。
变量名和等号之间不能有空格。
重要的事情说三遍，你要知道调试shell，就像java里System.out.println(&ldquo;ok&rdquo;)一样麻烦，更何况shell木有断点功能。目前我还不知道shell的ide，或者打断点，如果你知道，请告诉我，让我试试。
使用变量 $someone $(some_two)  只读变量 readonly someone  删除变量 unset someone  0x03 字符串 单引号 someone=&#39;Lee&#39;   单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；">

<meta property="og:title" content="初探Shell" />
<meta property="og:description" content="You got to put the past behind you before you can move on.
 由于项目上的需要开始接触shell，其实shell早就有过接触，只不过这次接触了，深入的思考了。
0x00 为什么用shell? 原来学习一门语言的时候都会这样问自己？但是大多数的答案都是：项目上需要。没有思考的余地，也就没有深入的思考。
现在开始用到，也学习了python,ruby,swift,javascript后发现，shell有她自身更好的发挥余地。比如我们经常会使用的命令cd,hugo server,git add -A等。别小看这些命令，一个一个来，还是要输入一会的。程序员不就图个安逸，一个shell脚本搞定的事情，为什么要多来输入几次呢？在举个例子，如果终端只有一个，那么要看tomcat的日志，还要更新类，那么就会来回的路径下切换，如果不用文本记录下来，光敲路径就花费很长的时间，so，用个shell脚本就可以解决了。当然，这个例子也不能说明shell的强大之处，那么这个例子就是shell的重要用途了。在零部署的时候，需要安装一些组件，数据库，初始化数据库脚本，注册服务，启动服务，关机。整个流程可以说一气呵成，但是如果是人工的话，那么想想工作量也是吓人的，这还不包括部署多台服务器呢。
如果是安装系统，会非常喜欢ghost版本，安装就step by step。而shell就提供了这样功能。当然有人会说python也一样搞定。是的，不可否认，但是如果python自身也需要安装库呢？所以，shell独天得厚的优势在于系统自带的同时，还可以自动安装所需的命令。
结论就是：如果你需要将命令step by step执行，那么就选择shell吧。
0x01 Hello,World! 每个学习程序设计的开始都会是这个，也因为这个才从此入坑。
创建文件hello.sh,输入一下内容：
#!/bin/bash echo &#39;Hello.World!&#39;  在终端中使用sh hello.sh,将输出以下结果：
Hello,World!  恭喜你，入门了。
思考：
 为什么第一行会有个#!/bin/bash echo 可以用单引号，也可以用双引号，区别是什么？ 如果要让shell脚步可以直接运行，怎么做？ 如何文件后缀是php,那么有该如何做呢？  0x02 变量 shell的变量命令基本和常用语言(pythoh/ruby/java/go)基本差不多，目前还没有遇到过坑。
那么如何定义一个变量呢？ someone=&quot;Lee&quot; some_two=&quot;http://10.10.10.222&quot;  看似简单的定义变量，如果写多了程序，就会有个问题，如下：
someone = &quot;Lee&quot; #Eroor  为什么会有这个错误，因为写代码的时候都喜欢来个空格，这样看着顺眼些，但是在shell里是错误的。因为变量名和等号之间不能有空格。
变量名和等号之间不能有空格。
变量名和等号之间不能有空格。
变量名和等号之间不能有空格。
重要的事情说三遍，你要知道调试shell，就像java里System.out.println(&ldquo;ok&rdquo;)一样麻烦，更何况shell木有断点功能。目前我还不知道shell的ide，或者打断点，如果你知道，请告诉我，让我试试。
使用变量 $someone $(some_two)  只读变量 readonly someone  删除变量 unset someone  0x03 字符串 单引号 someone=&#39;Lee&#39;   单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://guobingyi.github.io/blog/%E5%88%9D%E6%8E%A2shell/" />
<meta property="article:published_time" content="2018-07-04T19:54:52+08:00" />
<meta property="article:modified_time" content="2018-07-04T19:54:52+08:00" />


<title>


     初探Shell 

</title>
<link rel="canonical" href="https://guobingyi.github.io/blog/%E5%88%9D%E6%8E%A2shell/">







<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/default.min.css">




<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Ubuntu+Mono:400,400i,700,700i|Raleway:500">



    
    <link rel="stylesheet" href="https://guobingyi.github.io/css/reset.css?t=2019-07-29%2017%3a08%3a57.308538%20%2b0800%20CST%20m%3d%2b0.469141123">
    <link rel="stylesheet" href="https://guobingyi.github.io/css/pygments.css?t=2019-07-29%2017%3a08%3a57.308538%20%2b0800%20CST%20m%3d%2b0.469141123">
    <link rel="stylesheet" href="https://guobingyi.github.io/css/main.css?t=2019-07-29%2017%3a08%3a57.308538%20%2b0800%20CST%20m%3d%2b0.469141123">
    
        <link rel="stylesheet" href="https://guobingyi.github.io/css/override.css?t=2019-07-29%2017%3a08%3a57.308538%20%2b0800%20CST%20m%3d%2b0.469141123">
    




<link rel="shortcut icon"

    href="https://guobingyi.github.io/img/leaf.ico"

>








</head>


<body lang="en">

<section class="header">
    <div class="container">
        <div class="content">
            
                
                
                
                
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                
                <a href="https://guobingyi.github.io/"><img class="avatar" src="https://guobingyi.github.io/img/profile.png" srcset="https://guobingyi.github.io/img/profile.png 1x"></a>
            
            <a href="https://guobingyi.github.io/"><div class="name">Arthur Dent</div></a>
            
            <nav>
                <ul>
                    
                        <li class="nav-blog"><a href="https://guobingyi.github.io/blog/"><span>Blog</span></a></li>
                    
                        <li class="nav-about"><a href="https://guobingyi.github.io/about/"><span>About</span></a></li>
                    
                        <li class="nav-code"><a href="https://guobingyi.github.io/code/"><span>Code</span></a></li>
                    
                        <li class="nav-life"><a href="https://guobingyi.github.io/life/"><span>Life</span></a></li>
                    
                        <li class="nav-opensource"><a href="https://guobingyi.github.io/opensource/"><span>OpenSource</span></a></li>
                    
                        <li class="nav-emacs"><a href="https://guobingyi.github.io/emacs/"><span>Emacs</span></a></li>
                    
                        <li class="nav-mac"><a href="https://guobingyi.github.io/mac/"><span>Mac</span></a></li>
                    
                        <li class="nav-book"><a href="https://guobingyi.github.io/book/"><span>Book</span></a></li>
                    
                        <li class="nav-movie"><a href="https://guobingyi.github.io/movie/"><span>Movie</span></a></li>
                    
                </ul>
            </nav>
        </div>
    </div>
</section>

<section class="icons">
    <div class="container">
        <div class="content">
        
            <a href="//github.com/guobingyi" target="_blank" rel="noopener"><img class="icon" src="https://guobingyi.github.io/img/github.svg" alt="github" /></a>
        

        

        

	

        

        

        

        

        

        

        

        
            <a href="mailto:likemi7@126.com"><img class="icon" src="https://guobingyi.github.io/img/email.svg" alt="email" /></a>
        

        

        
        </div>
    </div>
</section>


<section class="main post non-narrow zero-top-spacing">
    <div class="container">
        <div class="content">
            <div class="front-matter">
                <div class="title-container">
                    <div class="page-heading">

    初探Shell

</div>

                    <div class="initials"><a href="https://guobingyi.github.io/">ad</a></div>
                </div>
                <div class="meta">
                    
                    <div class="date" title='Wed Jul 4 2018 19:54:52 CST'>Jul 4, 2018</div>
                    
                    
		    <div class="reading-time"><div class="middot"></div>5 minutes read</div>
                    
                </div>
            </div>
            <div class="markdown">
                

<blockquote>
<p>You got to put the past behind you before you can move on.</p>
</blockquote>

<p>由于项目上的需要开始接触shell，其实shell早就有过接触，只不过这次接触了，深入的思考了。</p>

<h2 id="0x00-为什么用shell">0x00 为什么用shell?</h2>

<p>原来学习一门语言的时候都会这样问自己？但是大多数的答案都是：项目上需要。没有思考的余地，也就没有深入的思考。</p>

<p>现在开始用到，也学习了python,ruby,swift,javascript后发现，shell有她自身更好的发挥余地。比如我们经常会使用的命令cd,hugo server,git add -A等。别小看这些命令，一个一个来，还是要输入一会的。程序员不就图个安逸，一个shell脚本搞定的事情，为什么要多来输入几次呢？在举个例子，如果终端只有一个，那么要看tomcat的日志，还要更新类，那么就会来回的路径下切换，如果不用文本记录下来，光敲路径就花费很长的时间，so，用个shell脚本就可以解决了。当然，这个例子也不能说明shell的强大之处，那么这个例子就是shell的重要用途了。在零部署的时候，需要安装一些组件，数据库，初始化数据库脚本，注册服务，启动服务，关机。整个流程可以说一气呵成，但是如果是人工的话，那么想想工作量也是吓人的，这还不包括部署多台服务器呢。</p>

<p>如果是安装系统，会非常喜欢ghost版本，安装就step by step。而shell就提供了这样功能。当然有人会说python也一样搞定。是的，不可否认，但是如果python自身也需要安装库呢？所以，shell独天得厚的优势在于系统自带的同时，还可以自动安装所需的命令。</p>

<p>结论就是：如果你需要将命令step by step执行，那么就选择shell吧。</p>

<h2 id="0x01-hello-world">0x01 Hello,World!</h2>

<p>每个学习程序设计的开始都会是这个，也因为这个才从此入坑。</p>

<p>创建文件hello.sh,输入一下内容：</p>

<pre><code>#!/bin/bash
echo 'Hello.World!'
</code></pre>

<p>在终端中使用sh hello.sh,将输出以下结果：</p>

<pre><code>Hello,World!
</code></pre>

<p>恭喜你，入门了。</p>

<p>思考：</p>

<ol>
<li>为什么第一行会有个#!/bin/bash</li>
<li>echo 可以用单引号，也可以用双引号，区别是什么？</li>
<li>如果要让shell脚步可以直接运行，怎么做？</li>
<li>如何文件后缀是php,那么有该如何做呢？</li>
</ol>

<h2 id="0x02-变量">0x02 变量</h2>

<p>shell的变量命令基本和常用语言(pythoh/ruby/java/go)基本差不多，目前还没有遇到过坑。</p>

<h3 id="那么如何定义一个变量呢">那么如何定义一个变量呢？</h3>

<pre><code>someone=&quot;Lee&quot;
some_two=&quot;http://10.10.10.222&quot;
</code></pre>

<p>看似简单的定义变量，如果写多了程序，就会有个问题，如下：</p>

<pre><code>someone = &quot;Lee&quot; #Eroor
</code></pre>

<p>为什么会有这个错误，因为写代码的时候都喜欢来个空格，这样看着顺眼些，但是在shell里是错误的。因为变量名和等号之间不能有空格。</p>

<p>变量名和等号之间不能有空格。</p>

<p>变量名和等号之间不能有空格。</p>

<p>变量名和等号之间不能有空格。</p>

<p>重要的事情说三遍，你要知道调试shell，就像java里System.out.println(&ldquo;ok&rdquo;)一样麻烦，更何况shell木有断点功能。目前我还不知道shell的ide，或者打断点，如果你知道，请告诉我，让我试试。</p>

<h3 id="使用变量">使用变量</h3>

<pre><code>$someone
$(some_two)
</code></pre>

<h3 id="只读变量">只读变量</h3>

<pre><code>readonly someone
</code></pre>

<h3 id="删除变量">删除变量</h3>

<pre><code>unset someone
</code></pre>

<h2 id="0x03-字符串">0x03 字符串</h2>

<h3 id="单引号">单引号</h3>

<pre><code>someone='Lee'
</code></pre>

<ul>
<li><p>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</p></li>

<li><p>单引号字串中不能出现单引号（对单引号使用转义符后也不行）。</p></li>
</ul>

<h3 id="双引号">双引号</h3>

<pre><code>someone=&quot;Lee,$some_two&quot;
</code></pre>

<h3 id="拼接字符串">拼接字符串</h3>

<pre><code>someone=&quot;World&quot;
sometwo=&quot;hello,&quot;$someone&quot;!&quot;
somethree=&quot;hello,${someone}!&quot;
echo sometwo somethree
</code></pre>

<h3 id="获取字符串长度">获取字符串长度</h3>

<pre><code>someone=&quot;hello&quot;
echo ${#someone} #输出5
</code></pre>

<h3 id="提取子字符串">提取子字符串</h3>

<pre><code>someone=&quot;some one like you!&quot;
echo ${someone:1:3} #输出ome,所以字符串的长度也是从0开始
</code></pre>

<h3 id="查找字符串">查找字符串</h3>

<pre><code>someone=&quot;some one like you!&quot;
echo `expr index &quot;$someone&quot; is` #output 2
</code></pre>

<h2 id="0x04-shell数组">0x04 Shell数组</h2>

<p>shell支持数组，但是不支持多维数组。</p>

<h3 id="定义数组">定义数组</h3>

<pre><code># one
someone=(val1 val2 val3)
#two
sometwo=(
v1
v2
v3
)
#three
arr[0]=key1
arr[1]=key2
arr[2]=key3

</code></pre>

<h3 id="获取数组值">获取数组值</h3>

<pre><code>#one value
temp=${arr[0]}
#all
echo ${arr[@]} #@ mean all
</code></pre>

<h3 id="数组长度">数组长度</h3>

<pre><code>#count
length=${#arr[@]}
#or
length=${#arr[*]}
#one array length
length=${#arr[0]}
</code></pre>

<h2 id="0x05-shell注释">0x05 shell注释</h2>

<p>shell里只能进行单行注释，已#开头的语句将会被注释掉。</p>

<pre><code># This is Comment!

# example shell script header 
#---------------------------------------------------
# author     :guoby
# date       :2018-07-05
# description: how to write comment in shell script
#---------------------------------------------------

</code></pre>

<p>如果没有多行注释不是太麻烦了？结论是有的。</p>

<blockquote>
<p>那种好使用那种，我感觉我在mac下要测试一下，感觉two在我电脑上没有问题。</p>
</blockquote>

<ul>
<li><p>one</p>

<pre><code>:&lt;&lt;EOF
comment!
comment!
comment!
EOF
</code></pre></li>

<li><p>two</p>

<pre><code>:&lt;&lt;'
comment
comment
comment
'
</code></pre></li>

<li><p>three</p>

<pre><code>:&lt;&lt;!
comment~~
comment~~
comment~~
!
</code></pre></li>
</ul>

<h2 id="0x06-shell参数传递">0x06 shell参数传递</h2>

<blockquote>
<p>参数使用#n来进行获取</p>
</blockquote>

<p>比如在终端执行:</p>

<pre><code>sh job.sh testload.sh 20 
</code></pre>

<ul>
<li><p>#0=job.sh</p></li>

<li><p>#1=testload.sh</p></li>

<li><p>#2=20</p></li>
</ul>

<p>更多参数如下表:</p>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>$#</td>
<td>参数个数</td>
</tr>

<tr>
<td>$*</td>
<td>参数数组</td>
</tr>

<tr>
<td>$$</td>
<td>脚本运行进程ID号</td>
</tr>

<tr>
<td>$!</td>
<td>后台运行的最后一个进程ID号</td>
</tr>

<tr>
<td>$@</td>
<td>参数数组，使用双引号包含内容</td>
</tr>

<tr>
<td>$-</td>
<td>当前选项</td>
</tr>

<tr>
<td>$?</td>
<td>退出状态，0表示正常退出。</td>
</tr>
</tbody>
</table>

<h2 id="0x07-shell基本运算符">0x07 shell基本运算符</h2>

<blockquote>
<p>shell和其他语言一样，支持多运算符。</p>
</blockquote>

<h3 id="算术运算符">算术运算符</h3>

<p>shell中使用expr来进行算术运算</p>

<pre><code>add=`expr $((3+4))` #7
</code></pre>

<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>

<tbody>
<tr>
<td>+</td>
<td>加法</td>
<td><code>expr $a+$b</code></td>
</tr>

<tr>
<td>-</td>
<td>减法</td>
<td><code>expr $a-$b</code></td>
</tr>

<tr>
<td>*</td>
<td>乘法</td>
<td><code>expr $a\*$b</code></td>
</tr>

<tr>
<td>/</td>
<td>除法</td>
<td><code>expr $a/$b</code></td>
</tr>

<tr>
<td>%</td>
<td>取余</td>
<td><code>expr $b%$a</code></td>
</tr>

<tr>
<td>=</td>
<td>赋值</td>
<td>a=$b</td>
</tr>

<tr>
<td>==</td>
<td>相等</td>
<td>[ $a==$b ]</td>
</tr>

<tr>
<td>!=</td>
<td>不相等</td>
<td>[ $a!=$b ]</td>
</tr>
</tbody>
</table>

<h3 id="关系运算符">关系运算符</h3>

<pre><code>a=1
b=2
</code></pre>

<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>

<tbody>
<tr>
<td>-eq</td>
<td>检查两个数是否相等，相等返回true</td>
<td>[ $a -eq $b ] 返回false</td>
</tr>

<tr>
<td>-ne</td>
<td>检测两个数是否不相等，不相等返回 true</td>
<td>[ $a -ne $b ] 返回 true</td>
</tr>

<tr>
<td>-gt</td>
<td>检测左边的数是否大于右边的，如果是，则返回 true</td>
<td>[ $a -gt $b ] 返回 false</td>
</tr>

<tr>
<td>-lt</td>
<td>检测左边的数是否小于右边的，如果是，则返回 true</td>
<td>[ $a -lt $b ] 返回 true</td>
</tr>

<tr>
<td>-ge</td>
<td>检测左边的数是否大于等于右边的，如果是，则返回 true</td>
<td>[ $a -ge $b ] 返回 false</td>
</tr>

<tr>
<td>-le</td>
<td>检测左边的数是否小于等于右边的，如果是，则返回 true</td>
<td>[ $a -le $b ] 返回 true</td>
</tr>
</tbody>
</table>

<h3 id="布尔运算符">布尔运算符</h3>

<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="center">说明</th>
<th align="right">举例</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">!</td>
<td align="center">非运算，表达式为 true 则返回 false，否则返回 true</td>
<td align="right">[ ! false ] 返回 true</td>
</tr>

<tr>
<td align="left">-o</td>
<td align="center">或运算，有一个表达式为 true 则返回 true</td>
<td align="right">[ $a -lt 20 -o $b -gt 100 ] 返回 true</td>
</tr>

<tr>
<td align="left">-a</td>
<td align="center">与运算，两个表达式都为 true 才返回 true</td>
<td align="right">[ $a -lt 20 -a $b -gt 100 ] 返回 false</td>
</tr>
</tbody>
</table>

<h3 id="逻辑运算符">逻辑运算符</h3>

<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">&amp;&amp;</td>
<td align="left">逻辑的 AND</td>
<td align="left">[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</td>
</tr>

<tr>
<td align="left">&#124;&#124;</td>
<td align="left">逻辑的 OR</td>
<td align="left">[[ $a -lt 100  &#124;&#124; $b -gt 100 ]] 返回 true</td>
</tr>
</tbody>
</table>

<h3 id="字符串运算符">字符串运算符</h3>

<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">=</td>
<td align="left">检测两个字符串是否相等，相等返回 true</td>
<td align="left">[ $a = $b ] 返回 false</td>
</tr>

<tr>
<td align="left">!=</td>
<td align="left">检测两个字符串是否相等，不相等返回 true</td>
<td align="left">[ $a != $b ] 返回 true</td>
</tr>

<tr>
<td align="left">-z</td>
<td align="left">检测字符串长度是否为0，为0返回 true</td>
<td align="left">[ -n &ldquo;$a&rdquo; ] 返回 true</td>
</tr>

<tr>
<td align="left">-n</td>
<td align="left">检测字符串长度是否为0，不为0返回 true</td>
<td align="left">[ -n &ldquo;$a&rdquo; ] 返回 true</td>
</tr>

<tr>
<td align="left">str</td>
<td align="left">检测字符串是否为空，不为空返回 true</td>
<td align="left">[ $a ] 返回 true</td>
</tr>
</tbody>
</table>

<h3 id="文件测试运算符">文件测试运算符</h3>

<blockquote>
<p>文件运算符用于检测Unix文件的各种属性。</p>
</blockquote>

<pre><code>file=&quot;~/test.sh&quot;
</code></pre>

<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">-b file</td>
<td align="left">检测文件是否是块设备文件，如果是，则返回 true</td>
<td align="left">[ -b $file ] 返回 false</td>
</tr>

<tr>
<td align="left">-c file</td>
<td align="left">检测文件是否是字符设备文件，如果是，则返回 true</td>
<td align="left">[ -c $file ] 返回 false</td>
</tr>

<tr>
<td align="left">-d file</td>
<td align="left">检测文件是否是目录，如果是，则返回 true</td>
<td align="left">[ -d $file ] 返回 false</td>
</tr>

<tr>
<td align="left">-f file</td>
<td align="left">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true</td>
<td align="left">[ -f $file ] 返回 true</td>
</tr>

<tr>
<td align="left">-g file</td>
<td align="left">检测文件是否设置了 SGID 位，如果是，则返回 true</td>
<td align="left">[ -g $file ] 返回 false</td>
</tr>

<tr>
<td align="left">-k file</td>
<td align="left">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true</td>
<td align="left">[ -k $file ] 返回 false</td>
</tr>

<tr>
<td align="left">-p file</td>
<td align="left">检测文件是否是有名管道，如果是，则返回 true</td>
<td align="left">[ -p $file ] 返回 false</td>
</tr>

<tr>
<td align="left">-u file</td>
<td align="left">检测文件是否设置了 SUID 位，如果是，则返回 true</td>
<td align="left">[ -u $file ] 返回 false</td>
</tr>

<tr>
<td align="left">-r file</td>
<td align="left">检测文件是否可读，如果是，则返回 true</td>
<td align="left">[ -r $file ] 返回 true</td>
</tr>

<tr>
<td align="left">-w file</td>
<td align="left">检测文件是否可写，如果是，则返回 true</td>
<td align="left">[ -w $file ] 返回 true</td>
</tr>

<tr>
<td align="left">-x file</td>
<td align="left">检测文件是否可执行，如果是，则返回 true</td>
<td align="left">[ -x $file ] 返回 true</td>
</tr>

<tr>
<td align="left">-s file</td>
<td align="left">检测文件是否为空（文件大小是否大于0），不为空返回 true</td>
<td align="left">[ -s $file ] 返回 true</td>
</tr>

<tr>
<td align="left">-e file</td>
<td align="left">检测文件（包括目录）是否存在，如果是，则返回 true</td>
<td align="left">[ -e $file ] 返回 true</td>
</tr>
</tbody>
</table>

<h2 id="0x08-shell-echo-command">0x08 shell echo command</h2>

<h3 id="显示普通字符串">显示普通字符串</h3>

<pre><code>echo &quot;Just fun!&quot;
</code></pre>

<h3 id="显示转义字符">显示转义字符</h3>

<pre><code>echo &quot;\&quot;This is demo!\&quot;&quot;
#output &quot;This is demo!&quot;
</code></pre>

<h3 id="显示变量">显示变量</h3>

<pre><code>yourname=&quot;Lee&quot;
echo &quot;you name is $yourname&quot;
#output you name is Lee
</code></pre>

<h3 id="显示换行">显示换行</h3>

<pre><code>echo -e &quot;Now,Let's talk about you life!\n&quot; # -e 开启转义
echo &quot;It sample.&quot;
</code></pre>

<pre><code>#output
Now,Let's talk about you life!

It sample.
</code></pre>

<h3 id="显示不换行">显示不换行</h3>

<pre><code>echo -e &quot;you work is \c&quot;
echo &quot;good!&quot;
#output you work is good!
</code></pre>

<h3 id="将结果输出到文件">将结果输出到文件</h3>

<pre><code>echo &quot;This comment in file.&quot; &gt; log.txt
</code></pre>

<h3 id="输出变量信息">输出变量信息</h3>

<pre><code>echo `$yourname\&quot;`
#output $yourname\&quot;
</code></pre>

<h3 id="显示命令执行结果">显示命令执行结果</h3>

<pre><code>echo `whoami`
#output root
</code></pre>

<h2 id="0x09-shell-printf-command">0x09 shell printf command</h2>

<blockquote>
<p>printf命令模仿C程序里的printf()函数。</p>
</blockquote>

<pre><code>printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重(kg)
printf &quot;%-10s %-8s %-4.2f\n&quot; 张三 男 54.333
printf &quot;%-10s %-8s %-4.2f\n&quot; 李四 男 66.234
printf &quot;%-10s %-8s %-4.2f\n&quot; 杨玉环 女 48.872
</code></pre>

<p>输出</p>

<pre><code>姓名   性别     体重
张三   男       54.33
李四   男       66.23
杨玉环 女       48.88
</code></pre>

<h3 id="转义序列">转义序列</h3>

<table>
<thead>
<tr>
<th align="left">序列</th>
<th align="left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">\a</td>
<td align="left">警告字符，通常为ASCII的BEL字符</td>
</tr>

<tr>
<td align="left">\b</td>
<td align="left">后退</td>
</tr>

<tr>
<td align="left">\c</td>
<td align="left">抑制（不显示）输出结果中任何结尾的换行字符</td>
</tr>

<tr>
<td align="left">\f</td>
<td align="left">换页（formfeed）</td>
</tr>

<tr>
<td align="left">\n</td>
<td align="left">换行</td>
</tr>

<tr>
<td align="left">\r</td>
<td align="left">回车</td>
</tr>

<tr>
<td align="left">\t</td>
<td align="left">水平制表符</td>
</tr>

<tr>
<td align="left">\v</td>
<td align="left">垂直制表符</td>
</tr>

<tr>
<td align="left">\</td>
<td align="left">反斜杠字符</td>
</tr>

<tr>
<td align="left">\ddd</td>
<td align="left">表示1到3位数八进制值的字符。仅在格式字符串中有效</td>
</tr>

<tr>
<td align="left">\0ddd</td>
<td align="left">表示1到3位的八进制值字符</td>
</tr>
</tbody>
</table>

<h2 id="0x10-shell-test-command">0x10 shell test command</h2>

<blockquote>
<p>shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p>
</blockquote>

<h3 id="数值测试">数值测试</h3>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">-eq</td>
<td align="left">等于则为真</td>
</tr>

<tr>
<td align="left">-ne</td>
<td align="left">不等则为真</td>
</tr>

<tr>
<td align="left">-gt</td>
<td align="left">大于则为真</td>
</tr>

<tr>
<td align="left">-ge</td>
<td align="left">大于等于则为真</td>
</tr>

<tr>
<td align="left">-lt</td>
<td align="left">小于则为真</td>
</tr>

<tr>
<td align="left">-le</td>
<td align="left">小于等于则为真</td>
</tr>
</tbody>
</table>

<pre><code>zs_age=28
ls_age=29

if test $[zs_age] -eq $[ls_age]
then 
	echo 'zs age equal ls'
else
	echo 'zs age no equal ls'
fi 

</code></pre>

<h3 id="字符串测试">字符串测试</h3>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">=</td>
<td align="left">等于则为真</td>
</tr>

<tr>
<td align="left">!=</td>
<td align="left">不等于则为真</td>
</tr>

<tr>
<td align="left">-z字符串</td>
<td align="left">字符串的长度为零则为真</td>
</tr>

<tr>
<td align="left">-n字符串</td>
<td align="left">字符串长度不为零则为真</td>
</tr>
</tbody>
</table>

<pre><code>zs_name=&quot;张三&quot;
ls_name=&quot;李四&quot;

if test $zs_name = $ls_name
then 
	echo &quot;两个名字一致&quot;
else
	echo &quot;两个名字不一致&quot;
fi 
</code></pre>

<h3 id="文件测试">文件测试</h3>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">-e文件名</td>
<td align="left">如果文件存在则为真</td>
</tr>

<tr>
<td align="left">-r文件名</td>
<td align="left">如果文件存在且可读则为真</td>
</tr>

<tr>
<td align="left">-w文件名</td>
<td align="left">如果文件存在且可写则为真</td>
</tr>

<tr>
<td align="left">-x文件名</td>
<td align="left">如果文件存在且可执行则为真</td>
</tr>

<tr>
<td align="left">-s文件名</td>
<td align="left">如果文件存在且至少有一个字符则为真</td>
</tr>

<tr>
<td align="left">-d文件名</td>
<td align="left">如果文件存在且为目录则为真</td>
</tr>

<tr>
<td align="left">-f文件名</td>
<td align="left">如果文件存在且为普通文件则为真</td>
</tr>

<tr>
<td align="left">-c文件名</td>
<td align="left">如果文件存在且为字符型特殊文件则为真</td>
</tr>

<tr>
<td align="left">-b文件名</td>
<td align="left">如果文件存在且为块特殊文件则为真</td>
</tr>
</tbody>
</table>

<h2 id="0x11-shell-控制流量">0x11 shell 控制流量</h2>

<h3 id="if-else">if else</h3>

<pre><code>if condition
then 
	command1
	command2
	...
	command3
else
	command5
if
</code></pre>

<pre><code>if condition
then
	command1
elif 
	command2
then
	command3
else
	commandn
fi
</code></pre>

<h3 id="for-循环">for 循环</h3>

<pre><code>for var in var1 var2 ... varn
do
	cmd1
	cmd2
	cmd3
	cmdn
done
</code></pre>

<h3 id="while-语句">while 语句</h3>

<pre><code>while condition
do
	cmd
done
</code></pre>

<h3 id="until-循环">until 循环</h3>

<pre><code>until condition
do 
	cmd 
done
</code></pre>

<h3 id="case">case</h3>

<pre><code>case 值 in 
条件1）
	cmd1
	;;
条件2）
	cmd2
	;;
esac
</code></pre>

<h3 id="break-continue">break continue</h3>

<blockquote>
<p>break 跳出所有循环</p>

<p>continue 跳出当前循环，继续下一次循环</p>
</blockquote>

<h3 id="esac">esac</h3>

<blockquote>
<p>case的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break。</p>
</blockquote>

<h2 id="0x12-shell-function">0x12 shell function</h2>

<blockquote>
<p>inux shell 可以用户定义函数。</p>
</blockquote>

<h3 id="函数定义">函数定义</h3>

<pre><code>[ function ] funname [()]

{

    action;

    [return int;]

}
</code></pre>

<p>说明：</p>

<ol>
<li><p>可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</p></li>

<li><p>参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)。</p></li>
</ol>

<h3 id="行数参数">行数参数</h3>

<p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数，依次类推。</p>

<h2 id="0x13-输入输出重定向">0x13 输入输出重定向</h2>

<p>重定向命令列表如下：</p>

<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">command &gt; file</td>
<td align="left">将输出重定向到 file</td>
</tr>

<tr>
<td align="left">command &lt; file</td>
<td align="left">将输入重定向到 file</td>
</tr>

<tr>
<td align="left">command &gt;&gt; file</td>
<td align="left">将输出以追加的方式重定向到 file</td>
</tr>

<tr>
<td align="left">n &gt; file</td>
<td align="left">将文件描述符为 n 的文件重定向到 file</td>
</tr>

<tr>
<td align="left">n &gt;&gt; file</td>
<td align="left">将文件描述符为 n 的文件以追加的方式重定向到 file</td>
</tr>

<tr>
<td align="left">n &gt;&amp; m</td>
<td align="left">将输出文件 m 和 n 合并</td>
</tr>

<tr>
<td align="left">n &lt;&amp; m</td>
<td align="left">将输入文件 m 和 n 合并</td>
</tr>

<tr>
<td align="left">&lt;&lt; tag</td>
<td align="left">将开始标记 tag 和结束标记 tag 之间的内容作为输入</td>
</tr>
</tbody>
</table>

<blockquote>
<p>需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p>
</blockquote>

<h3 id="dev-null-文件">/dev/null 文件</h3>

<p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null</p>

<pre><code>$ command &gt; /dev/null
</code></pre>

<p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到&rdquo;禁止输出&rdquo;的效果。</p>

<p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p>

<pre><code>$ command &gt; /dev/null 2&gt;&amp;1
</code></pre>

<h2 id="0x14-引用文件">0x14 引用文件</h2>

<p>和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。</p>

<p>Shell 文件包含的语法格式如下：</p>

<pre><code>. filename   # 注意点号(.)和文件名中间有一空格

或

source filename
</code></pre>

<p>实例</p>

<pre><code>#sh_test1.sh
name=&quot;guoby&quot;
</code></pre>

<pre><code>#sh_test2.sh

#使用 . 号来引用sh_test1.sh 文件
. ./sh_test2.sh
echo &quot;you name is $name&quot;
</code></pre>

<h1 id="结论">结论</h1>

<p>shell适用于在<strong><em>命令集合</em></strong>的情况下完成任务，并不适合于复杂的程序任务。</p>

<p>最实用的实用场景：发布部署应用。</p>

                <br>
                
                <p class="back-to-posts"><a href="https://guobingyi.github.io/blog">Back to posts</a></p>
            </div>
            <br>
            
            
        </div>
    </div>
</section>



<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-123-45', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>
  

  <script type="text/javascript">
    hljs.initHighlightingOnLoad();
  </script>





</body>
</html>

