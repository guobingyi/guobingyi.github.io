<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>guobingyi  | 初探Shell</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.54.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="https://guobingyi.github.io/dist/css/app.ab4b67a3ea25990fa8279f3b7ef08b61.css" rel="stylesheet">
    

    

    
      
    

    

    <meta property="og:title" content="初探Shell" />
<meta property="og:description" content="You got to put the past behind you before you can move on.
 由于项目上的需要开始接触shell，其实shell早就有过接触，只不过这次接触了，深入的思考了。
0x00 为什么用shell? 原来学习一门语言的时候都会这样问自己？但是大多数的答案都是：项目上需要。没有思考的余地，也就没有深入的思考。
现在开始用到，也学习了python,ruby,swift,javascript后发现，shell有她自身更好的发挥余地。比如我们经常会使用的命令cd,hugo server,git add -A等。别小看这些命令，一个一个来，还是要输入一会的。程序员不就图个安逸，一个shell脚本搞定的事情，为什么要多来输入几次呢？在举个例子，如果终端只有一个，那么要看tomcat的日志，还要更新类，那么就会来回的路径下切换，如果不用文本记录下来，光敲路径就花费很长的时间，so，用个shell脚本就可以解决了。当然，这个例子也不能说明shell的强大之处，那么这个例子就是shell的重要用途了。在零部署的时候，需要安装一些组件，数据库，初始化数据库脚本，注册服务，启动服务，关机。整个流程可以说一气呵成，但是如果是人工的话，那么想想工作量也是吓人的，这还不包括部署多台服务器呢。
如果是安装系统，会非常喜欢ghost版本，安装就step by step。而shell就提供了这样功能。当然有人会说python也一样搞定。是的，不可否认，但是如果python自身也需要安装库呢？所以，shell独天得厚的优势在于系统自带的同时，还可以自动安装所需的命令。
结论就是：如果你需要将命令step by step执行，那么就选择shell吧。
0x01 Hello,World! 每个学习程序设计的开始都会是这个，也因为这个才从此入坑。
创建文件hello.sh,输入一下内容：
#!/bin/bash echo &#39;Hello.World!&#39;  在终端中使用sh hello.sh,将输出以下结果：
Hello,World!  恭喜你，入门了。
思考：
 为什么第一行会有个#!/bin/bash echo 可以用单引号，也可以用双引号，区别是什么？ 如果要让shell脚步可以直接运行，怎么做？ 如何文件后缀是php,那么有该如何做呢？  0x02 变量 shell的变量命令基本和常用语言(pythoh/ruby/java/go)基本差不多，目前还没有遇到过坑。
那么如何定义一个变量呢？ someone=&quot;Lee&quot; some_two=&quot;http://10.10.10.222&quot;  看似简单的定义变量，如果写多了程序，就会有个问题，如下：
someone = &quot;Lee&quot; #Eroor  为什么会有这个错误，因为写代码的时候都喜欢来个空格，这样看着顺眼些，但是在shell里是错误的。因为变量名和等号之间不能有空格。
变量名和等号之间不能有空格。
变量名和等号之间不能有空格。
变量名和等号之间不能有空格。
重要的事情说三遍，你要知道调试shell，就像java里System.out.println(&ldquo;ok&rdquo;)一样麻烦，更何况shell木有断点功能。目前我还不知道shell的ide，或者打断点，如果你知道，请告诉我，让我试试。
使用变量 $someone $(some_two)  只读变量 readonly someone  删除变量 unset someone  0x03 字符串 单引号 someone=&#39;Lee&#39;   单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://guobingyi.github.io/blog/%E5%88%9D%E6%8E%A2shell/" />
<meta property="article:published_time" content="2018-07-04T19:54:52&#43;08:00"/>
<meta property="article:modified_time" content="2018-07-04T19:54:52&#43;08:00"/>

<meta itemprop="name" content="初探Shell">
<meta itemprop="description" content="You got to put the past behind you before you can move on.
 由于项目上的需要开始接触shell，其实shell早就有过接触，只不过这次接触了，深入的思考了。
0x00 为什么用shell? 原来学习一门语言的时候都会这样问自己？但是大多数的答案都是：项目上需要。没有思考的余地，也就没有深入的思考。
现在开始用到，也学习了python,ruby,swift,javascript后发现，shell有她自身更好的发挥余地。比如我们经常会使用的命令cd,hugo server,git add -A等。别小看这些命令，一个一个来，还是要输入一会的。程序员不就图个安逸，一个shell脚本搞定的事情，为什么要多来输入几次呢？在举个例子，如果终端只有一个，那么要看tomcat的日志，还要更新类，那么就会来回的路径下切换，如果不用文本记录下来，光敲路径就花费很长的时间，so，用个shell脚本就可以解决了。当然，这个例子也不能说明shell的强大之处，那么这个例子就是shell的重要用途了。在零部署的时候，需要安装一些组件，数据库，初始化数据库脚本，注册服务，启动服务，关机。整个流程可以说一气呵成，但是如果是人工的话，那么想想工作量也是吓人的，这还不包括部署多台服务器呢。
如果是安装系统，会非常喜欢ghost版本，安装就step by step。而shell就提供了这样功能。当然有人会说python也一样搞定。是的，不可否认，但是如果python自身也需要安装库呢？所以，shell独天得厚的优势在于系统自带的同时，还可以自动安装所需的命令。
结论就是：如果你需要将命令step by step执行，那么就选择shell吧。
0x01 Hello,World! 每个学习程序设计的开始都会是这个，也因为这个才从此入坑。
创建文件hello.sh,输入一下内容：
#!/bin/bash echo &#39;Hello.World!&#39;  在终端中使用sh hello.sh,将输出以下结果：
Hello,World!  恭喜你，入门了。
思考：
 为什么第一行会有个#!/bin/bash echo 可以用单引号，也可以用双引号，区别是什么？ 如果要让shell脚步可以直接运行，怎么做？ 如何文件后缀是php,那么有该如何做呢？  0x02 变量 shell的变量命令基本和常用语言(pythoh/ruby/java/go)基本差不多，目前还没有遇到过坑。
那么如何定义一个变量呢？ someone=&quot;Lee&quot; some_two=&quot;http://10.10.10.222&quot;  看似简单的定义变量，如果写多了程序，就会有个问题，如下：
someone = &quot;Lee&quot; #Eroor  为什么会有这个错误，因为写代码的时候都喜欢来个空格，这样看着顺眼些，但是在shell里是错误的。因为变量名和等号之间不能有空格。
变量名和等号之间不能有空格。
变量名和等号之间不能有空格。
变量名和等号之间不能有空格。
重要的事情说三遍，你要知道调试shell，就像java里System.out.println(&ldquo;ok&rdquo;)一样麻烦，更何况shell木有断点功能。目前我还不知道shell的ide，或者打断点，如果你知道，请告诉我，让我试试。
使用变量 $someone $(some_two)  只读变量 readonly someone  删除变量 unset someone  0x03 字符串 单引号 someone=&#39;Lee&#39;   单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；">


<meta itemprop="datePublished" content="2018-07-04T19:54:52&#43;08:00" />
<meta itemprop="dateModified" content="2018-07-04T19:54:52&#43;08:00" />
<meta itemprop="wordCount" content="1064">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="初探Shell"/>
<meta name="twitter:description" content="You got to put the past behind you before you can move on.
 由于项目上的需要开始接触shell，其实shell早就有过接触，只不过这次接触了，深入的思考了。
0x00 为什么用shell? 原来学习一门语言的时候都会这样问自己？但是大多数的答案都是：项目上需要。没有思考的余地，也就没有深入的思考。
现在开始用到，也学习了python,ruby,swift,javascript后发现，shell有她自身更好的发挥余地。比如我们经常会使用的命令cd,hugo server,git add -A等。别小看这些命令，一个一个来，还是要输入一会的。程序员不就图个安逸，一个shell脚本搞定的事情，为什么要多来输入几次呢？在举个例子，如果终端只有一个，那么要看tomcat的日志，还要更新类，那么就会来回的路径下切换，如果不用文本记录下来，光敲路径就花费很长的时间，so，用个shell脚本就可以解决了。当然，这个例子也不能说明shell的强大之处，那么这个例子就是shell的重要用途了。在零部署的时候，需要安装一些组件，数据库，初始化数据库脚本，注册服务，启动服务，关机。整个流程可以说一气呵成，但是如果是人工的话，那么想想工作量也是吓人的，这还不包括部署多台服务器呢。
如果是安装系统，会非常喜欢ghost版本，安装就step by step。而shell就提供了这样功能。当然有人会说python也一样搞定。是的，不可否认，但是如果python自身也需要安装库呢？所以，shell独天得厚的优势在于系统自带的同时，还可以自动安装所需的命令。
结论就是：如果你需要将命令step by step执行，那么就选择shell吧。
0x01 Hello,World! 每个学习程序设计的开始都会是这个，也因为这个才从此入坑。
创建文件hello.sh,输入一下内容：
#!/bin/bash echo &#39;Hello.World!&#39;  在终端中使用sh hello.sh,将输出以下结果：
Hello,World!  恭喜你，入门了。
思考：
 为什么第一行会有个#!/bin/bash echo 可以用单引号，也可以用双引号，区别是什么？ 如果要让shell脚步可以直接运行，怎么做？ 如何文件后缀是php,那么有该如何做呢？  0x02 变量 shell的变量命令基本和常用语言(pythoh/ruby/java/go)基本差不多，目前还没有遇到过坑。
那么如何定义一个变量呢？ someone=&quot;Lee&quot; some_two=&quot;http://10.10.10.222&quot;  看似简单的定义变量，如果写多了程序，就会有个问题，如下：
someone = &quot;Lee&quot; #Eroor  为什么会有这个错误，因为写代码的时候都喜欢来个空格，这样看着顺眼些，但是在shell里是错误的。因为变量名和等号之间不能有空格。
变量名和等号之间不能有空格。
变量名和等号之间不能有空格。
变量名和等号之间不能有空格。
重要的事情说三遍，你要知道调试shell，就像java里System.out.println(&ldquo;ok&rdquo;)一样麻烦，更何况shell木有断点功能。目前我还不知道shell的ide，或者打断点，如果你知道，请告诉我，让我试试。
使用变量 $someone $(some_two)  只读变量 readonly someone  删除变量 unset someone  0x03 字符串 单引号 someone=&#39;Lee&#39;   单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；"/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://guobingyi.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      guobingyi
    </a>
    <div class="flex-l items-center">
      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="https://guobingyi.github.io/blog/" title="Blog page">
              Blog
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="https://guobingyi.github.io/about/" title="About page">
              About
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="https://guobingyi.github.io/code/" title="Code page">
              Code
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="https://guobingyi.github.io/life/" title="Life page">
              Life
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="https://guobingyi.github.io/opensource/" title="OpenSource page">
              OpenSource
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="https://guobingyi.github.io/emacs/" title="Emacs page">
              Emacs
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="https://guobingyi.github.io/mac/" title="Mac page">
              Mac
            </a>
          </li>
          
        </ul>
      
      







  <a href="//github.com/guobingyi" class="link-transition github link dib z-999 pt3 pt0-l mr2" title="Github link">
    <svg  height="32px"  style="enable-background:new 0 0 512 512;" version="1.1" viewBox="0 0 512 512" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
  <path d="M256,32C132.3,32,32,134.8,32,261.7c0,101.5,64.2,187.5,153.2,217.9c11.2,2.1,15.3-5,15.3-11.1   c0-5.5-0.2-19.9-0.3-39.1c-62.3,13.9-75.5-30.8-75.5-30.8c-10.2-26.5-24.9-33.6-24.9-33.6c-20.3-14.3,1.5-14,1.5-14   c22.5,1.6,34.3,23.7,34.3,23.7c20,35.1,52.4,25,65.2,19.1c2-14.8,7.8-25,14.2-30.7c-49.7-5.8-102-25.5-102-113.5   c0-25.1,8.7-45.6,23-61.6c-2.3-5.8-10-29.2,2.2-60.8c0,0,18.8-6.2,61.6,23.5c17.9-5.1,37-7.6,56.1-7.7c19,0.1,38.2,2.6,56.1,7.7   c42.8-29.7,61.5-23.5,61.5-23.5c12.2,31.6,4.5,55,2.2,60.8c14.3,16.1,23,36.6,23,61.6c0,88.2-52.4,107.6-102.3,113.3   c8,7.1,15.2,21.1,15.2,42.5c0,30.7-0.3,55.5-0.3,63c0,6.1,4,13.3,15.4,11C415.9,449.1,480,363.1,480,261.7   C480,134.8,379.7,32,256,32z"/>
</svg>

  </a>


    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  <article class="flex-l flex-wrap justify-between mw8 center">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        BLOG
      </p>
      <h1 class="f1 athelas mb1">初探Shell</h1>
      
      <time class="f6 mv4 dib tracked" datetime="2018-07-04T19:54:52&#43;08:00">July 4, 2018</time>
    </header>

    <main class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<blockquote>
<p>You got to put the past behind you before you can move on.</p>
</blockquote>

<p>由于项目上的需要开始接触shell，其实shell早就有过接触，只不过这次接触了，深入的思考了。</p>

<h2 id="0x00-为什么用shell">0x00 为什么用shell?</h2>

<p>原来学习一门语言的时候都会这样问自己？但是大多数的答案都是：项目上需要。没有思考的余地，也就没有深入的思考。</p>

<p>现在开始用到，也学习了python,ruby,swift,javascript后发现，shell有她自身更好的发挥余地。比如我们经常会使用的命令cd,hugo server,git add -A等。别小看这些命令，一个一个来，还是要输入一会的。程序员不就图个安逸，一个shell脚本搞定的事情，为什么要多来输入几次呢？在举个例子，如果终端只有一个，那么要看tomcat的日志，还要更新类，那么就会来回的路径下切换，如果不用文本记录下来，光敲路径就花费很长的时间，so，用个shell脚本就可以解决了。当然，这个例子也不能说明shell的强大之处，那么这个例子就是shell的重要用途了。在零部署的时候，需要安装一些组件，数据库，初始化数据库脚本，注册服务，启动服务，关机。整个流程可以说一气呵成，但是如果是人工的话，那么想想工作量也是吓人的，这还不包括部署多台服务器呢。</p>

<p>如果是安装系统，会非常喜欢ghost版本，安装就step by step。而shell就提供了这样功能。当然有人会说python也一样搞定。是的，不可否认，但是如果python自身也需要安装库呢？所以，shell独天得厚的优势在于系统自带的同时，还可以自动安装所需的命令。</p>

<p>结论就是：如果你需要将命令step by step执行，那么就选择shell吧。</p>

<h2 id="0x01-hello-world">0x01 Hello,World!</h2>

<p>每个学习程序设计的开始都会是这个，也因为这个才从此入坑。</p>

<p>创建文件hello.sh,输入一下内容：</p>

<pre><code>#!/bin/bash
echo 'Hello.World!'
</code></pre>

<p>在终端中使用sh hello.sh,将输出以下结果：</p>

<pre><code>Hello,World!
</code></pre>

<p>恭喜你，入门了。</p>

<p>思考：</p>

<ol>
<li>为什么第一行会有个#!/bin/bash</li>
<li>echo 可以用单引号，也可以用双引号，区别是什么？</li>
<li>如果要让shell脚步可以直接运行，怎么做？</li>
<li>如何文件后缀是php,那么有该如何做呢？</li>
</ol>

<h2 id="0x02-变量">0x02 变量</h2>

<p>shell的变量命令基本和常用语言(pythoh/ruby/java/go)基本差不多，目前还没有遇到过坑。</p>

<h3 id="那么如何定义一个变量呢">那么如何定义一个变量呢？</h3>

<pre><code>someone=&quot;Lee&quot;
some_two=&quot;http://10.10.10.222&quot;
</code></pre>

<p>看似简单的定义变量，如果写多了程序，就会有个问题，如下：</p>

<pre><code>someone = &quot;Lee&quot; #Eroor
</code></pre>

<p>为什么会有这个错误，因为写代码的时候都喜欢来个空格，这样看着顺眼些，但是在shell里是错误的。因为变量名和等号之间不能有空格。</p>

<p>变量名和等号之间不能有空格。</p>

<p>变量名和等号之间不能有空格。</p>

<p>变量名和等号之间不能有空格。</p>

<p>重要的事情说三遍，你要知道调试shell，就像java里System.out.println(&ldquo;ok&rdquo;)一样麻烦，更何况shell木有断点功能。目前我还不知道shell的ide，或者打断点，如果你知道，请告诉我，让我试试。</p>

<h3 id="使用变量">使用变量</h3>

<pre><code>$someone
$(some_two)
</code></pre>

<h3 id="只读变量">只读变量</h3>

<pre><code>readonly someone
</code></pre>

<h3 id="删除变量">删除变量</h3>

<pre><code>unset someone
</code></pre>

<h2 id="0x03-字符串">0x03 字符串</h2>

<h3 id="单引号">单引号</h3>

<pre><code>someone='Lee'
</code></pre>

<ul>
<li><p>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</p></li>

<li><p>单引号字串中不能出现单引号（对单引号使用转义符后也不行）。</p></li>
</ul>

<h3 id="双引号">双引号</h3>

<pre><code>someone=&quot;Lee,$some_two&quot;
</code></pre>

<h3 id="拼接字符串">拼接字符串</h3>

<pre><code>someone=&quot;World&quot;
sometwo=&quot;hello,&quot;$someone&quot;!&quot;
somethree=&quot;hello,${someone}!&quot;
echo sometwo somethree
</code></pre>

<h3 id="获取字符串长度">获取字符串长度</h3>

<pre><code>someone=&quot;hello&quot;
echo ${#someone} #输出5
</code></pre>

<h3 id="提取子字符串">提取子字符串</h3>

<pre><code>someone=&quot;some one like you!&quot;
echo ${someone:1:3} #输出ome,所以字符串的长度也是从0开始
</code></pre>

<h3 id="查找字符串">查找字符串</h3>

<pre><code>someone=&quot;some one like you!&quot;
echo `expr index &quot;$someone&quot; is` #output 2
</code></pre>

<h2 id="0x04-shell数组">0x04 Shell数组</h2>

<p>shell支持数组，但是不支持多维数组。</p>

<h3 id="定义数组">定义数组</h3>

<pre><code># one
someone=(val1 val2 val3)
#two
sometwo=(
v1
v2
v3
)
#three
arr[0]=key1
arr[1]=key2
arr[2]=key3

</code></pre>

<h3 id="获取数组值">获取数组值</h3>

<pre><code>#one value
temp=${arr[0]}
#all
echo ${arr[@]} #@ mean all
</code></pre>

<h3 id="数组长度">数组长度</h3>

<pre><code>#count
length=${#arr[@]}
#or
length=${#arr[*]}
#one array length
length=${#arr[0]}
</code></pre>

<h2 id="0x05-shell注释">0x05 shell注释</h2>

<p>shell里只能进行单行注释，已#开头的语句将会被注释掉。</p>

<pre><code># This is Comment!

# example shell script header 
#---------------------------------------------------
# author     :guoby
# date       :2018-07-05
# description: how to write comment in shell script
#---------------------------------------------------

</code></pre>

<p>如果没有多行注释不是太麻烦了？结论是有的。</p>

<blockquote>
<p>那种好使用那种，我感觉我在mac下要测试一下，感觉two在我电脑上没有问题。</p>
</blockquote>

<ul>
<li>one</li>
</ul>

<pre><code>:&lt;&lt;EOF
comment!
comment!
comment!
EOF
</code></pre>

<ul>
<li>two</li>
</ul>

<pre><code>:&lt;&lt;'
comment
comment
comment
'
</code></pre>

<ul>
<li>three</li>
</ul>

<pre><code>:&lt;&lt;!
comment~~
comment~~
comment~~
!
</code></pre>

<h2 id="0x06-shell参数传递">0x06 shell参数传递</h2>

<blockquote>
<p>参数使用#n来进行获取</p>
</blockquote>

<p>比如在终端执行:</p>

<pre><code>sh job.sh testload.sh 20 
</code></pre>

<ul>
<li><p>#0=job.sh</p></li>

<li><p>#1=testload.sh</p></li>

<li><p>#2=20</p></li>
</ul>

<p>更多参数如下表:</p>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>$#</td>
<td>参数个数</td>
</tr>

<tr>
<td>$*</td>
<td>参数数组</td>
</tr>

<tr>
<td>$$</td>
<td>脚本运行进程ID号</td>
</tr>

<tr>
<td>$!</td>
<td>后台运行的最后一个进程ID号</td>
</tr>

<tr>
<td>$@</td>
<td>参数数组，使用双引号包含内容</td>
</tr>

<tr>
<td>$-</td>
<td>当前选项</td>
</tr>

<tr>
<td>$?</td>
<td>退出状态，0表示正常退出。</td>
</tr>
</tbody>
</table>

<h2 id="0x07-shell基本运算符">0x07 shell基本运算符</h2>

<blockquote>
<p>shell和其他语言一样，支持多运算符。</p>
</blockquote>

<h3 id="算术运算符">算术运算符</h3>

<p>shell中使用expr来进行算术运算</p>

<pre><code>add=`expr $((3+4))` #7
</code></pre>

<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>

<tbody>
<tr>
<td>+</td>
<td>加法</td>
<td><code>expr $a+$b</code></td>
</tr>

<tr>
<td>-</td>
<td>减法</td>
<td><code>expr $a-$b</code></td>
</tr>

<tr>
<td>*</td>
<td>乘法</td>
<td><code>expr $a\*$b</code></td>
</tr>

<tr>
<td>/</td>
<td>除法</td>
<td><code>expr $a/$b</code></td>
</tr>

<tr>
<td>%</td>
<td>取余</td>
<td><code>expr $b%$a</code></td>
</tr>

<tr>
<td>=</td>
<td>赋值</td>
<td>a=$b</td>
</tr>

<tr>
<td>==</td>
<td>相等</td>
<td>[ $a==$b ]</td>
</tr>

<tr>
<td>!=</td>
<td>不相等</td>
<td>[ $a!=$b ]</td>
</tr>
</tbody>
</table>

<h3 id="关系运算符">关系运算符</h3>

<pre><code>a=1
b=2
</code></pre>

<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>

<tbody>
<tr>
<td>-eq</td>
<td>检查两个数是否相等，相等返回true</td>
<td>[ $a -eq $b ] 返回false</td>
</tr>

<tr>
<td>-ne</td>
<td>检测两个数是否不相等，不相等返回 true</td>
<td>[ $a -ne $b ] 返回 true</td>
</tr>

<tr>
<td>-gt</td>
<td>检测左边的数是否大于右边的，如果是，则返回 true</td>
<td>[ $a -gt $b ] 返回 false</td>
</tr>

<tr>
<td>-lt</td>
<td>检测左边的数是否小于右边的，如果是，则返回 true</td>
<td>[ $a -lt $b ] 返回 true</td>
</tr>

<tr>
<td>-ge</td>
<td>检测左边的数是否大于等于右边的，如果是，则返回 true</td>
<td>[ $a -ge $b ] 返回 false</td>
</tr>

<tr>
<td>-le</td>
<td>检测左边的数是否小于等于右边的，如果是，则返回 true</td>
<td>[ $a -le $b ] 返回 true</td>
</tr>
</tbody>
</table>

<h3 id="布尔运算符">布尔运算符</h3>

<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="center">说明</th>
<th align="right">举例</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">!</td>
<td align="center">非运算，表达式为 true 则返回 false，否则返回 true</td>
<td align="right">[ ! false ] 返回 true</td>
</tr>

<tr>
<td align="left">-o</td>
<td align="center">或运算，有一个表达式为 true 则返回 true</td>
<td align="right">[ $a -lt 20 -o $b -gt 100 ] 返回 true</td>
</tr>

<tr>
<td align="left">-a</td>
<td align="center">与运算，两个表达式都为 true 才返回 true</td>
<td align="right">[ $a -lt 20 -a $b -gt 100 ] 返回 false</td>
</tr>
</tbody>
</table>

<h3 id="逻辑运算符">逻辑运算符</h3>

<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">&amp;&amp;</td>
<td align="left">逻辑的 AND</td>
<td align="left">[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</td>
</tr>

<tr>
<td align="left">&#124;&#124;</td>
<td align="left">逻辑的 OR</td>
<td align="left">[[ $a -lt 100  &#124;&#124; $b -gt 100 ]] 返回 true</td>
</tr>
</tbody>
</table>

<h3 id="字符串运算符">字符串运算符</h3>

<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">=</td>
<td align="left">检测两个字符串是否相等，相等返回 true</td>
<td align="left">[ $a = $b ] 返回 false</td>
</tr>

<tr>
<td align="left">!=</td>
<td align="left">检测两个字符串是否相等，不相等返回 true</td>
<td align="left">[ $a != $b ] 返回 true</td>
</tr>

<tr>
<td align="left">-z</td>
<td align="left">检测字符串长度是否为0，为0返回 true</td>
<td align="left">[ -n &ldquo;$a&rdquo; ] 返回 true</td>
</tr>

<tr>
<td align="left">-n</td>
<td align="left">检测字符串长度是否为0，不为0返回 true</td>
<td align="left">[ -n &ldquo;$a&rdquo; ] 返回 true</td>
</tr>

<tr>
<td align="left">str</td>
<td align="left">检测字符串是否为空，不为空返回 true</td>
<td align="left">[ $a ] 返回 true</td>
</tr>
</tbody>
</table>

<h3 id="文件测试运算符">文件测试运算符</h3>

<blockquote>
<p>文件运算符用于检测Unix文件的各种属性。</p>
</blockquote>

<pre><code>file=&quot;~/test.sh&quot;
</code></pre>

<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">-b file</td>
<td align="left">检测文件是否是块设备文件，如果是，则返回 true</td>
<td align="left">[ -b $file ] 返回 false</td>
</tr>

<tr>
<td align="left">-c file</td>
<td align="left">检测文件是否是字符设备文件，如果是，则返回 true</td>
<td align="left">[ -c $file ] 返回 false</td>
</tr>

<tr>
<td align="left">-d file</td>
<td align="left">检测文件是否是目录，如果是，则返回 true</td>
<td align="left">[ -d $file ] 返回 false</td>
</tr>

<tr>
<td align="left">-f file</td>
<td align="left">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true</td>
<td align="left">[ -f $file ] 返回 true</td>
</tr>

<tr>
<td align="left">-g file</td>
<td align="left">检测文件是否设置了 SGID 位，如果是，则返回 true</td>
<td align="left">[ -g $file ] 返回 false</td>
</tr>

<tr>
<td align="left">-k file</td>
<td align="left">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true</td>
<td align="left">[ -k $file ] 返回 false</td>
</tr>

<tr>
<td align="left">-p file</td>
<td align="left">检测文件是否是有名管道，如果是，则返回 true</td>
<td align="left">[ -p $file ] 返回 false</td>
</tr>

<tr>
<td align="left">-u file</td>
<td align="left">检测文件是否设置了 SUID 位，如果是，则返回 true</td>
<td align="left">[ -u $file ] 返回 false</td>
</tr>

<tr>
<td align="left">-r file</td>
<td align="left">检测文件是否可读，如果是，则返回 true</td>
<td align="left">[ -r $file ] 返回 true</td>
</tr>

<tr>
<td align="left">-w file</td>
<td align="left">检测文件是否可写，如果是，则返回 true</td>
<td align="left">[ -w $file ] 返回 true</td>
</tr>

<tr>
<td align="left">-x file</td>
<td align="left">检测文件是否可执行，如果是，则返回 true</td>
<td align="left">[ -x $file ] 返回 true</td>
</tr>

<tr>
<td align="left">-s file</td>
<td align="left">检测文件是否为空（文件大小是否大于0），不为空返回 true</td>
<td align="left">[ -s $file ] 返回 true</td>
</tr>

<tr>
<td align="left">-e file</td>
<td align="left">检测文件（包括目录）是否存在，如果是，则返回 true</td>
<td align="left">[ -e $file ] 返回 true</td>
</tr>
</tbody>
</table>

<h2 id="0x08-shell-echo-command">0x08 shell echo command</h2>

<h3 id="显示普通字符串">显示普通字符串</h3>

<pre><code>echo &quot;Just fun!&quot;
</code></pre>

<h3 id="显示转义字符">显示转义字符</h3>

<pre><code>echo &quot;\&quot;This is demo!\&quot;&quot;
#output &quot;This is demo!&quot;
</code></pre>

<h3 id="显示变量">显示变量</h3>

<pre><code>yourname=&quot;Lee&quot;
echo &quot;you name is $yourname&quot;
#output you name is Lee
</code></pre>

<h3 id="显示换行">显示换行</h3>

<pre><code>echo -e &quot;Now,Let's talk about you life!\n&quot; # -e 开启转义
echo &quot;It sample.&quot;
</code></pre>

<pre><code>#output
Now,Let's talk about you life!

It sample.
</code></pre>

<h3 id="显示不换行">显示不换行</h3>

<pre><code>echo -e &quot;you work is \c&quot;
echo &quot;good!&quot;
#output you work is good!
</code></pre>

<h3 id="将结果输出到文件">将结果输出到文件</h3>

<pre><code>echo &quot;This comment in file.&quot; &gt; log.txt
</code></pre>

<h3 id="输出变量信息">输出变量信息</h3>

<pre><code>echo `$yourname\&quot;`
#output $yourname\&quot;
</code></pre>

<h3 id="显示命令执行结果">显示命令执行结果</h3>

<pre><code>echo `whoami`
#output root
</code></pre>

<h2 id="0x09-shell-printf-command">0x09 shell printf command</h2>

<blockquote>
<p>printf命令模仿C程序里的printf()函数。</p>
</blockquote>

<pre><code>printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重(kg)
printf &quot;%-10s %-8s %-4.2f\n&quot; 张三 男 54.333
printf &quot;%-10s %-8s %-4.2f\n&quot; 李四 男 66.234
printf &quot;%-10s %-8s %-4.2f\n&quot; 杨玉环 女 48.872
</code></pre>

<p>输出</p>

<pre><code>姓名   性别     体重
张三   男       54.33
李四   男       66.23
杨玉环 女       48.88
</code></pre>

<h3 id="转义序列">转义序列</h3>

<table>
<thead>
<tr>
<th align="left">序列</th>
<th align="left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">\a</td>
<td align="left">警告字符，通常为ASCII的BEL字符</td>
</tr>

<tr>
<td align="left">\b</td>
<td align="left">后退</td>
</tr>

<tr>
<td align="left">\c</td>
<td align="left">抑制（不显示）输出结果中任何结尾的换行字符</td>
</tr>

<tr>
<td align="left">\f</td>
<td align="left">换页（formfeed）</td>
</tr>

<tr>
<td align="left">\n</td>
<td align="left">换行</td>
</tr>

<tr>
<td align="left">\r</td>
<td align="left">回车</td>
</tr>

<tr>
<td align="left">\t</td>
<td align="left">水平制表符</td>
</tr>

<tr>
<td align="left">\v</td>
<td align="left">垂直制表符</td>
</tr>

<tr>
<td align="left">\</td>
<td align="left">反斜杠字符</td>
</tr>

<tr>
<td align="left">\ddd</td>
<td align="left">表示1到3位数八进制值的字符。仅在格式字符串中有效</td>
</tr>

<tr>
<td align="left">\0ddd</td>
<td align="left">表示1到3位的八进制值字符</td>
</tr>
</tbody>
</table>

<h2 id="0x10-shell-test-command">0x10 shell test command</h2>

<blockquote>
<p>shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p>
</blockquote>

<h3 id="数值测试">数值测试</h3>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">-eq</td>
<td align="left">等于则为真</td>
</tr>

<tr>
<td align="left">-ne</td>
<td align="left">不等则为真</td>
</tr>

<tr>
<td align="left">-gt</td>
<td align="left">大于则为真</td>
</tr>

<tr>
<td align="left">-ge</td>
<td align="left">大于等于则为真</td>
</tr>

<tr>
<td align="left">-lt</td>
<td align="left">小于则为真</td>
</tr>

<tr>
<td align="left">-le</td>
<td align="left">小于等于则为真</td>
</tr>
</tbody>
</table>

<pre><code>zs_age=28
ls_age=29

if test $[zs_age] -eq $[ls_age]
then 
	echo 'zs age equal ls'
else
	echo 'zs age no equal ls'
fi 

</code></pre>

<h3 id="字符串测试">字符串测试</h3>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">=</td>
<td align="left">等于则为真</td>
</tr>

<tr>
<td align="left">!=</td>
<td align="left">不等于则为真</td>
</tr>

<tr>
<td align="left">-z字符串</td>
<td align="left">字符串的长度为零则为真</td>
</tr>

<tr>
<td align="left">-n字符串</td>
<td align="left">字符串长度不为零则为真</td>
</tr>
</tbody>
</table>

<pre><code>zs_name=&quot;张三&quot;
ls_name=&quot;李四&quot;

if test $zs_name = $ls_name
then 
	echo &quot;两个名字一致&quot;
else
	echo &quot;两个名字不一致&quot;
fi 
</code></pre>

<h3 id="文件测试">文件测试</h3>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">-e文件名</td>
<td align="left">如果文件存在则为真</td>
</tr>

<tr>
<td align="left">-r文件名</td>
<td align="left">如果文件存在且可读则为真</td>
</tr>

<tr>
<td align="left">-w文件名</td>
<td align="left">如果文件存在且可写则为真</td>
</tr>

<tr>
<td align="left">-x文件名</td>
<td align="left">如果文件存在且可执行则为真</td>
</tr>

<tr>
<td align="left">-s文件名</td>
<td align="left">如果文件存在且至少有一个字符则为真</td>
</tr>

<tr>
<td align="left">-d文件名</td>
<td align="left">如果文件存在且为目录则为真</td>
</tr>

<tr>
<td align="left">-f文件名</td>
<td align="left">如果文件存在且为普通文件则为真</td>
</tr>

<tr>
<td align="left">-c文件名</td>
<td align="left">如果文件存在且为字符型特殊文件则为真</td>
</tr>

<tr>
<td align="left">-b文件名</td>
<td align="left">如果文件存在且为块特殊文件则为真</td>
</tr>
</tbody>
</table>

<h2 id="0x11-shell-控制流量">0x11 shell 控制流量</h2>

<h3 id="if-else">if else</h3>

<pre><code>if condition
then 
	command1
	command2
	...
	command3
else
	command5
if
</code></pre>

<pre><code>if condition
then
	command1
elif 
	command2
then
	command3
else
	commandn
fi
</code></pre>

<h3 id="for-循环">for 循环</h3>

<pre><code>for var in var1 var2 ... varn
do
	cmd1
	cmd2
	cmd3
	cmdn
done
</code></pre>

<h3 id="while-语句">while 语句</h3>

<pre><code>while condition
do
	cmd
done
</code></pre>

<h3 id="until-循环">until 循环</h3>

<pre><code>until condition
do 
	cmd 
done
</code></pre>

<h3 id="case">case</h3>

<pre><code>case 值 in 
条件1）
	cmd1
	;;
条件2）
	cmd2
	;;
esac
</code></pre>

<h3 id="break-continue">break continue</h3>

<blockquote>
<p>break 跳出所有循环</p>

<p>continue 跳出当前循环，继续下一次循环</p>
</blockquote>

<h3 id="esac">esac</h3>

<blockquote>
<p>case的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break。</p>
</blockquote>

<h2 id="0x12-shell-function">0x12 shell function</h2>

<blockquote>
<p>inux shell 可以用户定义函数。</p>
</blockquote>

<h3 id="函数定义">函数定义</h3>

<pre><code>[ function ] funname [()]

{

    action;

    [return int;]

}
</code></pre>

<p>说明：</p>

<ol>
<li><p>可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</p></li>

<li><p>参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)。</p></li>
</ol>

<h3 id="行数参数">行数参数</h3>

<p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数，依次类推。</p>

<h2 id="0x13-输入输出重定向">0x13 输入输出重定向</h2>

<p>重定向命令列表如下：</p>

<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">command &gt; file</td>
<td align="left">将输出重定向到 file</td>
</tr>

<tr>
<td align="left">command &lt; file</td>
<td align="left">将输入重定向到 file</td>
</tr>

<tr>
<td align="left">command &gt;&gt; file</td>
<td align="left">将输出以追加的方式重定向到 file</td>
</tr>

<tr>
<td align="left">n &gt; file</td>
<td align="left">将文件描述符为 n 的文件重定向到 file</td>
</tr>

<tr>
<td align="left">n &gt;&gt; file</td>
<td align="left">将文件描述符为 n 的文件以追加的方式重定向到 file</td>
</tr>

<tr>
<td align="left">n &gt;&amp; m</td>
<td align="left">将输出文件 m 和 n 合并</td>
</tr>

<tr>
<td align="left">n &lt;&amp; m</td>
<td align="left">将输入文件 m 和 n 合并</td>
</tr>

<tr>
<td align="left">&lt;&lt; tag</td>
<td align="left">将开始标记 tag 和结束标记 tag 之间的内容作为输入</td>
</tr>
</tbody>
</table>

<blockquote>
<p>需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p>
</blockquote>

<h3 id="dev-null-文件">/dev/null 文件</h3>

<p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null</p>

<pre><code>$ command &gt; /dev/null
</code></pre>

<p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到&rdquo;禁止输出&rdquo;的效果。</p>

<p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p>

<pre><code>$ command &gt; /dev/null 2&gt;&amp;1
</code></pre>

<h2 id="0x14-引用文件">0x14 引用文件</h2>

<p>和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。</p>

<p>Shell 文件包含的语法格式如下：</p>

<pre><code>. filename   # 注意点号(.)和文件名中间有一空格

或

source filename
</code></pre>

<p>实例</p>

<pre><code>#sh_test1.sh
name=&quot;guoby&quot;
</code></pre>

<pre><code>#sh_test2.sh

#使用 . 号来引用sh_test1.sh 文件
. ./sh_test2.sh
echo &quot;you name is $name&quot;
</code></pre>

<h1 id="结论">结论</h1>

<p>shell适用于在<strong><em>命令集合</em></strong>的情况下完成任务，并不适合于复杂的程序任务。</p>

<p>最实用的实用场景：发布部署应用。</p>
<ul class="pa0">
  
</ul>
<div class="mt6">
        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "cocoaexamplesite" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </div>
    </main>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-near-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://guobingyi.github.io/" >
    &copy; 2019 guobingyi
  </a>
  







  <a href="//github.com/guobingyi" class="link-transition github link dib z-999 pt3 pt0-l mr2" title="Github link">
    <svg  height="32px"  style="enable-background:new 0 0 512 512;" version="1.1" viewBox="0 0 512 512" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
  <path d="M256,32C132.3,32,32,134.8,32,261.7c0,101.5,64.2,187.5,153.2,217.9c11.2,2.1,15.3-5,15.3-11.1   c0-5.5-0.2-19.9-0.3-39.1c-62.3,13.9-75.5-30.8-75.5-30.8c-10.2-26.5-24.9-33.6-24.9-33.6c-20.3-14.3,1.5-14,1.5-14   c22.5,1.6,34.3,23.7,34.3,23.7c20,35.1,52.4,25,65.2,19.1c2-14.8,7.8-25,14.2-30.7c-49.7-5.8-102-25.5-102-113.5   c0-25.1,8.7-45.6,23-61.6c-2.3-5.8-10-29.2,2.2-60.8c0,0,18.8-6.2,61.6,23.5c17.9-5.1,37-7.6,56.1-7.7c19,0.1,38.2,2.6,56.1,7.7   c42.8-29.7,61.5-23.5,61.5-23.5c12.2,31.6,4.5,55,2.2,60.8c14.3,16.1,23,36.6,23,61.6c0,88.2-52.4,107.6-102.3,113.3   c8,7.1,15.2,21.1,15.2,42.5c0,30.7-0.3,55.5-0.3,63c0,6.1,4,13.3,15.4,11C415.9,449.1,480,363.1,480,261.7   C480,134.8,379.7,32,256,32z"/>
</svg>

  </a>


  </div>
</footer>

    

  <script src="https://guobingyi.github.io/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
