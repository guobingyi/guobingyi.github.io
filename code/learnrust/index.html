<!DOCTYPE html>
<html lang="zh-cn">

<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">
<meta name="author" content="Arthur Dent">
<meta name="description" content="Rust 学习笔记 自从在工作是使用了Go语言后，就不断的打破原来的模式，想什么都用Go来实现，可惜有些东西，特别是Windows下的窗口程序，就无能为力了，其他的好像都可以试一试。因为关注Go，所以Node的作者想重新写Node的时候，选择了Go，最后居然换成了Rust。这不得不让我对这门语言有了新的看法，特别是微软和Google都要推Rust的时候，我放弃了我原来对这门语言的偏见，重新、认真的学习一遍，让我看看到底是什么让它受到那么多人的关注。
前言 系统级别的语言，可以和C/C&#43;&#43;抗衡？目标就是为了取代C&#43;&#43;。
介绍 Rust语言能够编写速度更快，更加可靠的软件。
学习笔记为1.52.1版本，如果你来晚了，最好参考 最新文档 来进行学习。你懂的～～
0x01 开始 1.目标 安装 写个输出hello world的程序 使用cargo工具来构建系统 2 安装 2.1 安装 其实在苹果电脑上，能用brew安装的，我一般都会使用。可惜，Rust推荐的最佳方式，并不是。😊
所以，使用Rust的安装方式，最佳。
$ curl --proto &#39;=https&#39; --tlsv1.2 https://sh.rustup.rs -sSf | sh 安装成功后，将在命令端输出：
Rust is installed now. Great! 2.2 更新 $ rustup update 2.3 删除 $ rustup self uninstall 使用了许多语言后，这个是发现最贴心的。
2.4 版本查看 $ rustc --version 2.5 阅读本地文档 rustup doc 3. Hello,World! 3.1 创建项目路径 $ mkdir ~/projects $ cd ~/projects $ mkdir hello_world $ cd hello_world 3.">

<meta property="og:title" content="LearnRust" />
<meta property="og:description" content="Rust 学习笔记 自从在工作是使用了Go语言后，就不断的打破原来的模式，想什么都用Go来实现，可惜有些东西，特别是Windows下的窗口程序，就无能为力了，其他的好像都可以试一试。因为关注Go，所以Node的作者想重新写Node的时候，选择了Go，最后居然换成了Rust。这不得不让我对这门语言有了新的看法，特别是微软和Google都要推Rust的时候，我放弃了我原来对这门语言的偏见，重新、认真的学习一遍，让我看看到底是什么让它受到那么多人的关注。
前言 系统级别的语言，可以和C/C&#43;&#43;抗衡？目标就是为了取代C&#43;&#43;。
介绍 Rust语言能够编写速度更快，更加可靠的软件。
学习笔记为1.52.1版本，如果你来晚了，最好参考 最新文档 来进行学习。你懂的～～
0x01 开始 1.目标 安装 写个输出hello world的程序 使用cargo工具来构建系统 2 安装 2.1 安装 其实在苹果电脑上，能用brew安装的，我一般都会使用。可惜，Rust推荐的最佳方式，并不是。😊
所以，使用Rust的安装方式，最佳。
$ curl --proto &#39;=https&#39; --tlsv1.2 https://sh.rustup.rs -sSf | sh 安装成功后，将在命令端输出：
Rust is installed now. Great! 2.2 更新 $ rustup update 2.3 删除 $ rustup self uninstall 使用了许多语言后，这个是发现最贴心的。
2.4 版本查看 $ rustc --version 2.5 阅读本地文档 rustup doc 3. Hello,World! 3.1 创建项目路径 $ mkdir ~/projects $ cd ~/projects $ mkdir hello_world $ cd hello_world 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://guobingyi.github.io/code/learnrust/" /><meta property="article:section" content="code" />
<meta property="article:published_time" content="2021-05-29T11:20:30+08:00" />
<meta property="article:modified_time" content="2021-05-29T11:20:30+08:00" />



<title>


     LearnRust 

</title>
<link rel="canonical" href="https://guobingyi.github.io/code/learnrust/">







  
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/default.min.css">
  




<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Ubuntu+Mono:400,400i,700,700i|Raleway:500">



    
    <link rel="stylesheet" href="https://guobingyi.github.io/css/reset.css?t=2022-06-22%2016%3a53%3a21.256012%20%2b0800%20CST%20m%3d%2b4.545856855">
    <link rel="stylesheet" href="https://guobingyi.github.io/css/pygments.css?t=2022-06-22%2016%3a53%3a21.256012%20%2b0800%20CST%20m%3d%2b4.545856855">
    <link rel="stylesheet" href="https://guobingyi.github.io/css/main.css?t=2022-06-22%2016%3a53%3a21.256012%20%2b0800%20CST%20m%3d%2b4.545856855">
    
        <link rel="stylesheet" href="https://guobingyi.github.io/css/override.css?t=2022-06-22%2016%3a53%3a21.256012%20%2b0800%20CST%20m%3d%2b4.545856855">
    




<link rel="shortcut icon"

    href="https://guobingyi.github.io/img/leaf.ico"

>










</head>


<body lang="en">

<section class="header">
    <div class="container">
        <div class="content">
            
                
                
                
                
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                
                <a href="https://guobingyi.github.io/"><img class="avatar" src="https://guobingyi.github.io/img/profile.png" srcset="https://guobingyi.github.io/img/profile.png 1x"></a>
            
            <a href="https://guobingyi.github.io/"><div class="name">Arthur Dent</div></a>
            
            <nav>
                <ul>
                    
                        
                        <li class="nav-blog"><a href="https://guobingyi.github.io/blog/"><span>Blog</span></a></li>
                    
                        
                        <li class="nav-movie"><a href="https://guobingyi.github.io/movie/"><span>Movie</span></a></li>
                    
                        
                        <li class="nav-code"><a href="https://guobingyi.github.io/code/"><span>Code</span></a></li>
                    
                        
                        <li class="nav-life"><a href="https://guobingyi.github.io/life/"><span>Life</span></a></li>
                    
                        
                        <li class="nav-opensource"><a href="https://guobingyi.github.io/opensource/"><span>OpenSource</span></a></li>
                    
                        
                        <li class="nav-emacs"><a href="https://guobingyi.github.io/emacs/"><span>Emacs</span></a></li>
                    
                        
                        <li class="nav-mac"><a href="https://guobingyi.github.io/mac/"><span>Mac</span></a></li>
                    
                        
                        <li class="nav-book"><a href="https://guobingyi.github.io/book/"><span>Book</span></a></li>
                    
                        
                        <li class="nav-about"><a href="https://guobingyi.github.io/about/"><span>About</span></a></li>
                    
                </ul>
            </nav>
        </div>
    </div>
</section>

<section class="icons">
    <div class="container">
        <div class="content">
        
            <a href="//github.com/guobingyi" target="_blank" rel="noopener"><img class="icon" src="https://guobingyi.github.io/img/github.svg" alt="github" /></a>
        

        

        

	

        

        

        

        

        

        

        

        

        
            <a href="mailto:likemi7@126.com"><img class="icon" src="https://guobingyi.github.io/img/email.svg" alt="email" /></a>
        

        
        
        

        
        </div>
    </div>
</section>

<section class="main">
    <div class="container">
        <div class="content">
            <div class="page-heading">

    LearnRust

</div>

            <div class="markdown">
                <h1 id="rust-学习笔记">Rust 学习笔记</h1>
<blockquote>
<p>自从在工作是使用了Go语言后，就不断的打破原来的模式，想什么都用Go来实现，可惜有些东西，特别是Windows下的窗口程序，就无能为力了，其他的好像都可以试一试。因为关注Go，所以Node的作者想重新写Node的时候，选择了Go，最后居然换成了Rust。这不得不让我对这门语言有了新的看法，特别是微软和Google都要推Rust的时候，我放弃了我原来对这门语言的偏见，重新、认真的学习一遍，让我看看到底是什么让它受到那么多人的关注。</p>
</blockquote>
<h2 id="前言">前言</h2>
<p>系统级别的语言，可以和C/C++抗衡？目标就是为了取代C++。</p>
<h2 id="介绍">介绍</h2>
<p>Rust语言能够编写速度更快，更加可靠的软件。</p>
<p>学习笔记为1.52.1版本，如果你来晚了，最好参考
<a href="https://doc.rust-lang.org/book/">最新文档</a> 来进行学习。你懂的～～</p>
<h2 id="0x01-开始">0x01 开始</h2>
<h3 id="1目标">1.目标</h3>
<ul>
<li>安装</li>
<li>写个输出hello world的程序</li>
<li>使用cargo工具来构建系统</li>
</ul>
<h3 id="2-安装">2 安装</h3>
<h4 id="21-安装">2.1 安装</h4>
<p>其实在苹果电脑上，能用brew安装的，我一般都会使用。可惜，Rust推荐的最佳方式，并不是。😊</p>
<p>所以，使用Rust的安装方式，最佳。</p>
<pre tabindex="0"><code>$ curl --proto &#39;=https&#39; --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre><p>安装成功后，将在命令端输出：</p>
<pre tabindex="0"><code>Rust is installed now. Great!
</code></pre><h4 id="22-更新">2.2 更新</h4>
<pre tabindex="0"><code>$ rustup update
</code></pre><h4 id="23-删除">2.3 删除</h4>
<pre tabindex="0"><code>$ rustup self uninstall
</code></pre><p><strong>使用了许多语言后，这个是发现最贴心的。</strong></p>
<h4 id="24-版本查看">2.4 版本查看</h4>
<pre tabindex="0"><code>$ rustc --version
</code></pre><h4 id="25-阅读本地文档">2.5 阅读本地文档</h4>
<pre tabindex="0"><code>rustup doc
</code></pre><h3 id="3-helloworld">3. Hello,World!</h3>
<h4 id="31-创建项目路径">3.1 创建项目路径</h4>
<pre tabindex="0"><code>$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre><h4 id="32-编写和运行rust程序">3.2 编写和运行Rust程序</h4>
<p>创建main.rs文件，编写以下代码：</p>
<pre tabindex="0"><code>fn main() {
    println!(&#34;Hello, world!&#34;);
}
</code></pre><p>编译和运行代码：</p>
<pre tabindex="0"><code>$ rustc main.rs
$ ./main
Hello, world!
</code></pre><p>rustc 编译单一的程序比较好，但是到真正的项目中还是推荐使用Cargo工具进行编译。</p>
<h3 id="4-hellocargo">4. Hello,Cargo!</h3>
<p>Cargo是Rust编译系统和包管理工具。</p>
<p>验证cargo是否安装成功：</p>
<pre tabindex="0"><code>cargo --version
</code></pre><h4 id="41-使用cargo创建项目">4.1 使用Cargo创建项目</h4>
<pre tabindex="0"><code>$ cargo new hello_cargo
$ cd hello_cargo
</code></pre><h4 id="42-编译和运行cargo项目">4.2 编译和运行Cargo项目</h4>
<p>编译代码：</p>
<pre tabindex="0"><code>$ cargo build
</code></pre><p>路径下执行代码：</p>
<pre tabindex="0"><code>$ ./target/debug/hello_cargo 
</code></pre><p>执行代码。</p>
<pre tabindex="0"><code>$ cargo run
</code></pre><p>检查代码，但是不产生可执行文件。</p>
<pre tabindex="0"><code>$ cargo check
</code></pre><h4 id="43-编译发布版本">4.3 编译发布版本</h4>
<pre tabindex="0"><code>$ cargo build --release
</code></pre><h3 id="5-猜谜程序">5. 猜谜程序</h3>
<h4 id="51-创建一个新项目">5.1 创建一个新项目</h4>
<pre tabindex="0"><code>$ cargo new guessing_game
$ cd guessing_game
</code></pre><h4 id="52-处理猜测">5.2 处理猜测</h4>
<pre tabindex="0"><code>use std::io;

fn main() {
    println!(&#34;Guess the number!&#34;);

    println!(&#34;Please input your guess.&#34;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&#34;Failed to read line&#34;);

    println!(&#34;You guessed: {}&#34;, guess);
}
</code></pre><h4 id="53-数值存储">5.3 数值存储</h4>
<pre tabindex="0"><code>let mut guess = String::new();
</code></pre><h4 id="54-处理异常">5.4 处理异常</h4>
<pre tabindex="0"><code> .expect(&#34;Failed to read line&#34;);
</code></pre><h4 id="55-使用println函数打印">5.5 使用println!函数打印</h4>
<pre tabindex="0"><code> println!(&#34;You guessed: {}&#34;, guess);
</code></pre><h4 id="56-添加依赖项">5.6 添加依赖项</h4>
<p>在文件Cargo.toml中添加：</p>
<pre tabindex="0"><code>[dependencies]
rand = &#34;0.8.3&#34;
</code></pre><h4 id="57-更新项目">5.7 更新项目</h4>
<pre tabindex="0"><code>$ cargo build
</code></pre><h4 id="58-更新依赖项版本">5.8 更新依赖项版本</h4>
<pre tabindex="0"><code>$ cargo update
    Updating crates.io index
    Updating rand v0.8.3 -&gt; v0.8.4
</code></pre><p>此时rand版本更新支最新。</p>
<p>或者直接打开 Cargo.toml，修改版本。</p>
<pre tabindex="0"><code>[dependencies]
rand = &#34;0.9.0&#34;
</code></pre><h4 id="59--创建一个随机数">5.9  创建一个随机数</h4>
<pre tabindex="0"><code>use std::io;
use rand::Rng;

fn main() {
    println!(&#34;Guess the number!&#34;);

    let secret_number = rand::thread_rng().gen_range(1..101);

    println!(&#34;The secret number is: {}&#34;, secret_number);

    println!(&#34;Please input your guess.&#34;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&#34;Failed to read line&#34;);

    println!(&#34;You guessed: {}&#34;, guess);
}
</code></pre><h4 id="510-比较大小">5.10 比较大小</h4>
<pre tabindex="0"><code>use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--

    println!(&#34;You guessed: {}&#34;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&#34;Too small!&#34;),
        Ordering::Greater =&gt; println!(&#34;Too big!&#34;),
        Ordering::Equal =&gt; println!(&#34;You win!&#34;),
    }
}
</code></pre><h4 id="511-添加循环">5.11 添加循环</h4>
<pre tabindex="0"><code>loop {
        println!(&#34;Please input your guess.&#34;);

        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&#34;Too small!&#34;),
            Ordering::Greater =&gt; println!(&#34;Too big!&#34;),
            Ordering::Equal =&gt; println!(&#34;You win!&#34;),
        }
    }
</code></pre><h4 id="512-跳出循环">5.12 跳出循环</h4>
<pre tabindex="0"><code>match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&#34;Too small!&#34;),
            Ordering::Greater =&gt; println!(&#34;Too big!&#34;),
            Ordering::Equal =&gt; {
                println!(&#34;You win!&#34;);
                break;
            }
        }
</code></pre><h4 id="513-处理异常输入">5.13 处理异常输入</h4>
<pre tabindex="0"><code>// --snip--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&#34;Failed to read line&#34;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&#34;You guessed: {}&#34;, guess);

// --snip--
</code></pre><h3 id="6-常见编程概念">6. 常见编程概念</h3>
<h4 id="61-变量和可变性">6.1 变量和可变性</h4>
<pre tabindex="0"><code>let x = 6; //x不能被赋值
let mut x =6; //x能被赋值
</code></pre><h4 id="62-变量与常量的差异">6.2 变量与常量的差异</h4>
<pre tabindex="0"><code>const MAX_POINTS: u32 = 100_000;
</code></pre><h4 id="63-阴影效果">6.3 阴影效果</h4>
<pre tabindex="0"><code>let spaces = &#34;   &#34;;
let spaces = spaces.len();
</code></pre><p>let 再次使用关键字时，重新创建了一个新变量。</p>
<p>但是以下的定义为错误：</p>
<pre tabindex="0"><code> let mut spaces = &#34;   &#34;;
 spaces = spaces.len();
</code></pre><p>此时spaces将变改变为整型，而非原来的字符型。</p>
<h4 id="64-数据类型">6.4 数据类型</h4>
<p>Rust是静态类型语言，编译时需要知道变量的类型。</p>
<p>例如：</p>
<pre tabindex="0"><code>let guess: u32 = &#34;42&#34;.parse().expect(&#34;Not a number!&#34;);
</code></pre><p>如果没有类型注释，如下所示：</p>
<pre tabindex="0"><code>let guess = &#34;42&#34;.parse().expect(&#34;Not a number!&#34;);
</code></pre><p>编译将出现错误。</p>
<pre tabindex="0"><code>$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &#34;42&#34;.parse().expect(&#34;Not a number!&#34;);
  |         ^^^^^ consider giving `guess` a type

error: aborting due to previous error

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations`

To learn more, run the command again with --verbose.
</code></pre><h5 id="641-标量类型">6.4.1 标量类型</h5>
<p>Rust 有四种主要的标量类型：整数、浮点数、布尔值和字符。</p>
<ul>
<li>1.整数类型</li>
</ul>
<table>
<thead>
<tr>
<th>Length</th>
<th>Signed</th>
<th>Unsigned</th>
</tr>
</thead>
<tbody>
<tr>
<td>8-bit</td>
<td>i8</td>
<td>u8</td>
</tr>
<tr>
<td>16-bit</td>
<td>i16</td>
<td>u16</td>
</tr>
<tr>
<td>32-bit</td>
<td>i32</td>
<td>u32</td>
</tr>
<tr>
<td>128-bit</td>
<td>i128</td>
<td>u128</td>
</tr>
<tr>
<td>arch</td>
<td>isize</td>
<td>usize</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Number literals</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Decimal</td>
<td>98_222</td>
</tr>
<tr>
<td>Hex</td>
<td>0xff</td>
</tr>
<tr>
<td>Octal</td>
<td>0o77</td>
</tr>
<tr>
<td>Binary</td>
<td>0b1111_0000</td>
</tr>
<tr>
<td>Byte</td>
<td>(u8 only)	b&rsquo;A'</td>
</tr>
</tbody>
</table>
<ul>
<li>2.浮点类型</li>
</ul>
<p>Rust 也有两种用于浮点数的原始类型，它们是带小数点的数字。Rust 的浮点类型是f32and f64，它们的大小分别是 32 位和 64 位。默认类型是f64。 因为在现代 CPU 上它的速度大致相同，f32但精度更高。</p>
<p>这是一个显示浮点数的示例：</p>
<pre tabindex="0"><code>fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre><p>浮点数根据 IEEE-754 标准表示。该 f32类型是单精度浮点数，f64具有双精度。</p>
<ul>
<li>3.数值运算</li>
</ul>
<pre tabindex="0"><code>fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;

    // remainder
    let remainder = 43 % 5;
}
</code></pre><ul>
<li>4.布尔类型</li>
</ul>
<p>与大多数其他编程语言一样，Rust 中的布尔类型有两个可能的值：true和false。布尔值大小为 1 个字节。Rust 中的布尔类型使用bool. 例如：</p>
<pre tabindex="0"><code>fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
</code></pre><ul>
<li>5.字符类型</li>
</ul>
<p>Rust 的char类型大小为四个字节，表示一个 Unicode 标量值，这意味着它可以表示的不仅仅是 ASCII。</p>
<pre tabindex="0"><code>fn main() {
    let c = &#39;z&#39;;
    let z = &#39;ℤ&#39;;
    let heart_eyed_cat = &#39;😻&#39;;
}
</code></pre><ul>
<li>6.复合类型</li>
</ul>
<p>复合类型可以将多个值分组为一种类型。Rust 有两种原始的复合类型：元组和数组。</p>
<p>1.元组类型</p>
<p>元组是将具有多种类型的多个值组合成一个复合类型的通用方法。元组有固定的长度：一旦声明，它们的大小就不能增长或缩小。</p>
<pre tabindex="0"><code>fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre><p>也可以使用模式匹配来解构元组值，如下所示：</p>
<pre tabindex="0"><code>fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&#34;The value of y is: {}&#34;, y);
}
</code></pre><p>除了通过模式匹配进行解构之外，我们还可以通过使用句点 ( .) 后跟我们想要访问的值的索引来直接访问元组元素。例如：</p>
<pre tabindex="0"><code>fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre><p>该程序创建一个元组 ，x然后使用它们各自的索引为每个元素创建新变量。与大多数编程语言一样，元组中的第一个索引是 0。</p>
<ul>
<li>7.数组类型</li>
</ul>
<p>在 Rust 中，进入数组的值被写为方括号内的逗号分隔列表：</p>
<pre tabindex="0"><code>fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre><p>在需要知道一年中月份名称的程序中，您可能想要使用数组而不是向量的示例。这样的程序不太可能需要添加或删除月份，因此您可以使用数组，因为您知道它始终包含 12 个元素：</p>
<pre tabindex="0"><code>let months = [&#34;January&#34;, &#34;February&#34;, &#34;March&#34;, &#34;April&#34;, &#34;May&#34;, &#34;June&#34;, &#34;July&#34;,
              &#34;August&#34;, &#34;September&#34;, &#34;October&#34;, &#34;November&#34;, &#34;December&#34;];
</code></pre><p>您可以使用方括号编写数组的类型，方括号内包含每个元素的类型、分号，然后是数组中的元素数，如下所示：</p>
<pre tabindex="0"><code>let a: [i32; 5] = [1, 2, 3, 4, 5];
</code></pre><p>这里，i32是每个元素的类型。分号后的数字5 表示数组包含五个元素。</p>
<p>以这种方式编写数组的类型看起来类似于初始化数组的另一种语法：如果您想创建一个数组，其中每个元素都包含相同的值，您可以指定初始值，后跟一个分号，然后是长度方括号中的数组，如下所示：</p>
<pre tabindex="0"><code>let a = [3; 5];
</code></pre><p>命名的数组a将包含5所有3最初设置为该值的元素 。这与写作相同，let a = [3, 3, 3, 3, 3];但方式更简洁。</p>
<p>访问数组元素,可以使用索引访问数组的元素，如下所示：</p>
<pre tabindex="0"><code>fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre><p>在这个例子中，named 的变量first将获得 value 1，因为这是[0]数组中索引处的值。命名的变量second将从数组中的2索引[1]中获取值。</p>
<h4 id="65-函数">6.5 函数</h4>
<p>函数在 Rust 代码中无处不在。您已经看到了该语言中最重要的函数之一：main函数，它是许多程序的入口点。您还看到了fn关键字，它允许您声明新函数。</p>
<p>Rust 代码使用蛇形大小写作为函数和变量名称的常规样式。在蛇的情况下，所有字母都是小写的，并用下划线分隔单词。这是一个包含示例函数定义的程序：</p>
<pre tabindex="0"><code>fn main() {
    println!(&#34;Hello, world!&#34;);

    another_function();
}

fn another_function() {
    println!(&#34;Another function.&#34;);
}
</code></pre><p>Rust 中的函数定义以fn函数名开头，并在函数名后有一组括号。大括号告诉编译器函数体的开始和结束位置。</p>
<p>Rust 不关心你在哪里定义你的函数，只关心它们是在某处定义的。</p>
<ul>
<li>1.功能参数</li>
</ul>
<pre tabindex="0"><code>fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!(&#34;The value of x is: {}&#34;, x);
}
</code></pre><p>一个函数有多个参数时，用逗号分隔参数声明，像这样：</p>
<pre tabindex="0"><code>fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!(&#34;The value of x is: {}&#34;, x);
    println!(&#34;The value of y is: {}&#34;, y);
}
</code></pre><p>创建新作用域的块{}是一个表达式，例如：</p>
<pre tabindex="0"><code>n main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!(&#34;The value of y is: {}&#34;, y);
}
</code></pre><ul>
<li>2.具有返回值的函数</li>
</ul>
<p>函数可以将值返回给调用它们的代码。我们不命名返回值，但我们确实在箭头 ( -&gt;)后声明它们的类型。在 Rust 中，函数的返回值与函数体块中最终表达式的值是同义词。您可以通过使用return关键字并指定值从函数中提前返回，但大多数函数会隐式返回最后一个表达式。下面是一个返回值的函数示例：</p>
<pre tabindex="0"><code>fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&#34;The value of x is: {}&#34;, x);
}
</code></pre><h4 id="66-注释">6.6 注释</h4>
<p>在 Rust 中，惯用的注释样式以两个斜杠开始注释，并且注释一直持续到行尾。对于超出单行的注释，您需要//在每一行中包含，如下所示：</p>
<pre tabindex="0"><code>// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.
</code></pre><p>注释也可以放在包含代码的行的末尾：</p>
<pre tabindex="0"><code>fn main() {
    let lucky_number = 7; // I’m feeling lucky today
}
</code></pre><p>但是你会更经常地看到它们以这种格式使用，注释在它所注释的代码上方的单独行上：</p>
<pre tabindex="0"><code>fn main() {
    // I’m feeling lucky today
    let lucky_number = 7;
}
</code></pre><p>Rust 还有另一种注释，文档注释，我们将在第 14 章的“将 Crate 发布到 Crates.io”一节中讨论。</p>
<h4 id="67控制流">6.7控制流</h4>
<ul>
<li>1.if表达式</li>
</ul>
<pre tabindex="0"><code>fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&#34;condition was true&#34;);
    } else {
        println!(&#34;condition was false&#34;);
    }
}
</code></pre><p>必须明确并始终提供 if布尔值作为其条件。</p>
<pre tabindex="0"><code>fn main() {
    let number = 3;

    if number != 0 {
        println!(&#34;number was something other than zero&#34;);
    }
}
</code></pre><ul>
<li>2.处理多个条件 else if</li>
</ul>
<pre tabindex="0"><code>fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&#34;number is divisible by 4&#34;);
    } else if number % 3 == 0 {
        println!(&#34;number is divisible by 3&#34;);
    } else if number % 2 == 0 {
        println!(&#34;number is divisible by 2&#34;);
    } else {
        println!(&#34;number is not divisible by 4, 3, or 2&#34;);
    }
}
</code></pre><ul>
<li>3.使用if的let语句</li>
</ul>
<pre tabindex="0"><code>fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!(&#34;The value of number is: {}&#34;, number);
}
</code></pre><ul>
<li>4.循环重复</li>
</ul>
<p>Rust有三种循环：loop，while，和for。</p>
<p>（1）重复代码 loop</p>
<p>该loop关键字告诉Rust永远比执行的代码块一遍又一遍，或者直到你明确告诉它停止。</p>
<pre tabindex="0"><code>fn main() {
    loop {
        println!(&#34;again!&#34;);
    }
}
</code></pre><p>从循环返回值</p>
<pre tabindex="0"><code>fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!(&#34;The result is {}&#34;, result);
}
</code></pre><p>(2)条件循环 while</p>
<pre tabindex="0"><code>fn main() {
    let mut number = 3;

    while number != 0 {
        println!(&#34;{}!&#34;, number);

        number -= 1;
    }

    println!(&#34;LIFTOFF!!!&#34;);
}
</code></pre><p>(3)循环遍历集合 for</p>
<p>while方式：</p>
<pre tabindex="0"><code>fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&#34;the value is: {}&#34;, a[index]);

        index += 1;
    }
}
</code></pre><p>for 方式：</p>
<pre tabindex="0"><code>fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!(&#34;the value is: {}&#34;, element);
    }
}
</code></pre><h3 id="7-所有权">7. 所有权</h3>
<p>所有权是 Rust 最独特的特性，它使 Rust 能够在不需要垃圾收集器的情况下做出内存安全保证。因此，了解所有权在 Rust 中的运作方式非常重要。在本章中，我们将讨论所有权以及几个相关的特性：借用、切片，以及 Rust 如何在内存中布置数据。</p>
<h4 id="1所有权规则">1.所有权规则</h4>
<ul>
<li>Rust 中的每个值都有一个变量，称为其owner。</li>
<li>一次只能有一个所有者。</li>
<li>当所有者超出范围时，该值将被删除。</li>
</ul>
<p><strong>读不懂了？？？</strong></p>
<h3 id="8结构">8.结构</h3>
<h4 id="81-定义和实例化结构">8.1 定义和实例化结构</h4>
<pre tabindex="0"><code>struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
</code></pre><pre tabindex="0"><code>let user1 = User {
        email: String::from(&#34;someone@example.com&#34;),
        username: String::from(&#34;someusername123&#34;),
        active: true,
        sign_in_count: 1,
    };
</code></pre><h4 id="82-结构方法语法">8.2 结构方法语法</h4>
<pre tabindex="0"><code>#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &#34;The area of the rectangle is {} square pixels.&#34;,
        rect1.area()
    );
}
</code></pre><h3 id="9枚举和模式匹配">9.枚举和模式匹配</h3>
<h4 id="91-定义枚举">9.1 定义枚举</h4>
<pre tabindex="0"><code>enum IpAddrKind {
    V4,
    V6,
}
</code></pre><h4 id="92-枚举值">9.2 枚举值</h4>
<pre tabindex="0"><code>let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
</code></pre><p>结合结构和枚举的使用：</p>
<pre tabindex="0"><code> enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from(&#34;127.0.0.1&#34;),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from(&#34;::1&#34;),
    };
</code></pre><h4 id="93-匹配控制流程操作符">9.3 匹配控制流程操作符</h4>
<pre tabindex="0"><code>enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
</code></pre><h4 id="94-_占位符">9.4 &ldquo;_&ldquo;占位符</h4>
<p>该_模式将匹配任何值。</p>
<pre tabindex="0"><code> let some_u8_value = 0u8;
    match some_u8_value {
        1 =&gt; println!(&#34;one&#34;),
        3 =&gt; println!(&#34;three&#34;),
        5 =&gt; println!(&#34;five&#34;),
        7 =&gt; println!(&#34;seven&#34;),
        _ =&gt; (),
    }
</code></pre><h4 id="95-if-let">9.5 if let</h4>
<pre tabindex="0"><code> let some_u8_value = Some(0u8);
   match some_u8_value {
       Some(3) =&gt; println!(&#34;three&#34;),
       _ =&gt; (),
   }
</code></pre><h3 id="10管理不断增长的项目">10.管理不断增长的项目</h3>
<ul>
<li>
<p>Packages: A Cargo feature that lets you build, test, and share crates</p>
</li>
<li>
<p>Crates: A tree of modules that produces a library or executable</p>
</li>
<li>
<p>Modules and use: Let you control the organization, scope, and privacy of paths</p>
</li>
<li>
<p>Paths: A way of naming an item, such as a struct, function, or module</p>
</li>
</ul>
<h4 id="101-packages-and-crates">10.1 Packages and Crates</h4>
<pre tabindex="0"><code> cargo new my-project
    Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre><h4 id="102-定义模块以控制范围和隐私">10.2 定义模块以控制范围和隐私</h4>
<p>文件名：src/lib.rs</p>
<pre tabindex="0"><code>mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
</code></pre><p>模块树：</p>
<pre tabindex="0"><code>crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre><h4 id="103-引用模块树中项目的路径">10.3 引用模块树中项目的路径</h4>
<pre tabindex="0"><code>mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre><h4 id="104-使用use关键字将路径纳入范围">10.4 使用use关键字将路径纳入范围</h4>
<pre tabindex="0"><code>mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
</code></pre><h4 id="105-将模块分成不同的文件">10.5 将模块分成不同的文件</h4>
<pre tabindex="0"><code>mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
</code></pre><h3 id="11-常见集合">11 常见集合</h3>
<p>Rust 的标准库包括许多非常有用的数据结构，称为集合。</p>
<h4 id="111-用向量存储值列表">11.1 用向量存储值列表</h4>
<p>我们将看到的第一个集合类型是Vec<!-- raw HTML omitted -->，也称为向量。向量允许您在单个数据结构中存储多个值，该数据结构将所有值并排放置在内存中。向量只能存储相同类型的值。当您有一个项目列表时，它们很有用，例如文件中的文本行或购物车中项目的价格。</p>
<ul>
<li>1.创建新向量</li>
</ul>
<pre tabindex="0"><code> let v: Vec&lt;i32&gt; = Vec::new();
</code></pre><ul>
<li>2.更新向量</li>
</ul>
<pre tabindex="0"><code>let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
</code></pre><h4 id="112-存储utf-8字符串">11.2 存储UTF-8字符串</h4>
<pre tabindex="0"><code>    let hello = String::from(&#34;السلام عليكم&#34;);
    let hello = String::from(&#34;Dobrý den&#34;);
    let hello = String::from(&#34;Hello&#34;);
    let hello = String::from(&#34;שָׁלוֹם&#34;);
    let hello = String::from(&#34;नमस्ते&#34;);
    let hello = String::from(&#34;こんにちは&#34;);
    let hello = String::from(&#34;안녕하세요&#34;);
    let hello = String::from(&#34;你好&#34;);
    let hello = String::from(&#34;Olá&#34;);
    let hello = String::from(&#34;Здравствуйте&#34;);
    let hello = String::from(&#34;Hola&#34;);
</code></pre><ul>
<li>1.添加字符串</li>
</ul>
<pre tabindex="0"><code>let mut s = String::from(&#34;lo&#34;);
s.push(&#39;l&#39;);
</code></pre><p>使用操作符 &ldquo;+&ldquo;进行字符串操作：</p>
<pre tabindex="0"><code>    let s1 = String::from(&#34;Hello, &#34;);
    let s2 = String::from(&#34;world!&#34;);
    let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used
</code></pre><h4 id="113-hashmap">11.3 HashMap</h4>
<pre tabindex="0"><code>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&#34;Blue&#34;), 10);
scores.insert(String::from(&#34;Yellow&#34;), 50);

//Accessing Values in a Hash Map
let team_name = String::from(&#34;Blue&#34;);
let score = scores.get(&amp;team_name);

for (key, value) in &amp;scores {
        println!(&#34;{}: {}&#34;, key, value);
    }

//Overwriting a Value
scores.insert(String::from(&#34;Blue&#34;), 25);
</code></pre><h3 id="12-错误处理">12 错误处理</h3>
<h4 id="121-panic">12.1 panic</h4>
<pre tabindex="0"><code>fn main() {
    panic!(&#34;crash and burn&#34;);
}
</code></pre><pre tabindex="0"><code>RUST_BACKTRACE=1 cargo run
</code></pre><p>打印错误详细信息。</p>
<h4 id="122-带错误信息的错误处理">12.2 带错误信息的错误处理</h4>
<pre tabindex="0"><code>use std::fs::File;

fn main() {
    let f = File::open(&#34;hello.txt&#34;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!(&#34;Problem opening the file: {:?}&#34;, error),
    };
}
</code></pre><p>多错误处理：</p>
<pre tabindex="0"><code>use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&#34;hello.txt&#34;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&#34;hello.txt&#34;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&#34;Problem creating the file: {:?}&#34;, e),
            },
            other_error =&gt; {
                panic!(&#34;Problem opening the file: {:?}&#34;, other_error)
            }
        },
    };
}
</code></pre><h4 id="123-何时使用panic">12.3 何时使用panic</h4>
<pre tabindex="0"><code>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&#34;Guess value must be between 1 and 100, got {}.&#34;, value);
        }

        Guess { value }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
</code></pre><h3 id="13泛型类型特性和生命周期">13.泛型类型、特性和生命周期</h3>
<p>提取函数，去重复</p>
<pre tabindex="0"><code>fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&#34;The largest number is {}&#34;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&#34;The largest number is {}&#34;, largest);
}
</code></pre><p>提取后，将转变为以下函数：</p>
<pre tabindex="0"><code>fn largest(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&#34;The largest number is {}&#34;, result);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&#34;The largest number is {}&#34;, result);
}
</code></pre><h4 id="131-通用数据类型">13.1 通用数据类型</h4>
<ul>
<li>1.函数定义</li>
</ul>
<pre tabindex="0"><code>fn largest_i32(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; char {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&#34;The largest number is {}&#34;, result);

    let char_list = vec![&#39;y&#39;, &#39;m&#39;, &#39;a&#39;, &#39;q&#39;];

    let result = largest_char(&amp;char_list);
    println!(&#34;The largest char is {}&#34;, result);
}
</code></pre><p>将数字比较和字符比较，都使用泛型的方式：</p>
<pre tabindex="0"><code>fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&#34;The largest number is {}&#34;, result);

    let char_list = vec![&#39;y&#39;, &#39;m&#39;, &#39;a&#39;, &#39;q&#39;];

    let result = largest(&amp;char_list);
    println!(&#34;The largest char is {}&#34;, result);
}
</code></pre><ul>
<li>2.结构定义</li>
</ul>
<pre tabindex="0"><code>struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre><ul>
<li>2.枚举定义</li>
</ul>
<pre tabindex="0"><code>enum Option&lt;T&gt; {
    Some(T),
    None,
}
</code></pre><p>或者</p>
<pre tabindex="0"><code>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre><ul>
<li>3.方法定义</li>
</ul>
<pre tabindex="0"><code>struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&#34;p.x = {}&#34;, p.x());
}
</code></pre><p>一个更加复杂的例子：</p>
<pre tabindex="0"><code>struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &#34;Hello&#34;, y: &#39;c&#39; };

    let p3 = p1.mixup(p2);

    println!(&#34;p3.x = {}, p3.y = {}&#34;, p3.x, p3.y);
}
</code></pre><ul>
<li>
<ol start="3">
<li>代码定义</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>let integer = Some(5);
let float = Some(5.0);
</code></pre><h4 id="132-特性定义共享行为">13.2 特性：定义共享行为</h4>
<p>定义特性：</p>
<pre tabindex="0"><code>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
</code></pre><p>在结构中分别实现：</p>
<pre tabindex="0"><code>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&#34;{}, by {} ({})&#34;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&#34;{}: {}&#34;, self.username, self.content)
    }
}
</code></pre><p>函数中使用特性：</p>
<pre tabindex="0"><code>fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&#34;The largest number is {}&#34;, result);

    let char_list = vec![&#39;y&#39;, &#39;m&#39;, &#39;a&#39;, &#39;q&#39;];

    let result = largest(&amp;char_list);
    println!(&#34;The largest char is {}&#34;, result);
}
</code></pre><h4 id="133-引用生命周期">13.3 引用生命周期</h4>
<ul>
<li>1.函数中的生命周期</li>
</ul>
<pre tabindex="0"><code>fn main() {
    let string1 = String::from(&#34;abcd&#34;);
    let string2 = &#34;xyz&#34;;

    let result = longest(string1.as_str(), string2);
    println!(&#34;The longest string is {}&#34;, result);
}
</code></pre><ul>
<li>2.生命周期注释语法</li>
</ul>
<pre tabindex="0"><code>&amp;i32        // a reference
&amp;&#39;a i32     // a reference with an explicit lifetime
&amp;&#39;a mut i32 // a mutable reference with an explicit lifetime
</code></pre><ul>
<li>3.函数中的生命周期注释</li>
</ul>
<pre tabindex="0"><code>fn longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;str) -&gt; &amp;&#39;a str {
    x
}
</code></pre><ul>
<li>4.静态生命周期</li>
</ul>
<pre tabindex="0"><code>let s: &amp;&#39;static str = &#34;I have a static lifetime.&#34;;
</code></pre><ul>
<li>5.通用类型参数、特征边界和生命周期</li>
</ul>
<pre tabindex="0"><code>use std::fmt::Display;

fn longest_with_an_announcement&lt;&#39;a, T&gt;(
    x: &amp;&#39;a str,
    y: &amp;&#39;a str,
    ann: T,
) -&gt; &amp;&#39;a str
where
    T: Display,
{
    println!(&#34;Announcement! {}&#34;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre><h3 id="14-编写自动化测试">14. 编写自动化测试</h3>
<pre tabindex="0"><code>cargo test --help
</code></pre><h4 id="141-如何编写测试">14.1 如何编写测试</h4>
<ul>
<li>1.编写自动化测试</li>
</ul>
<pre tabindex="0"><code>#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!(&#34;Make this test fail&#34;);
    }
}
</code></pre><h4 id="142">14.2</h4>
<p>并行测试</p>
<pre tabindex="0"><code>$ cargo test -- --test-threads=1
</code></pre><p>显示输出信息：</p>
<pre tabindex="0"><code>cargo test -- --show-output
</code></pre><p>测试函数：</p>
<pre tabindex="0"><code>pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
</code></pre><pre tabindex="0"><code>cargo test one_hundred
</code></pre><p>匹配函数名称进行测试，所有的add开头都会被测试：</p>
<pre tabindex="0"><code>cargo test add
</code></pre><p>忽略测试标记：</p>
<pre tabindex="0"><code>#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}
</code></pre><pre tabindex="0"><code>cargo test -- --ignored
</code></pre><h4 id="143-测试结构">14.3 测试结构</h4>
<ul>
<li>1.单元测试</li>
</ul>
<pre tabindex="0"><code>#[cfg(test)]
</code></pre><pre tabindex="0"><code>#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre><ul>
<li>2.私有函数测试</li>
</ul>
<pre tabindex="0"><code>pub fn add_two(a: i32) -&gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
</code></pre><h3 id="15-一个读写项目构建一个命令行程序">15. 一个读写项目：构建一个命令行程序</h3>
<h4 id="151-接收命令行参数">15.1 接收命令行参数</h4>
<ul>
<li>1.读取参数</li>
</ul>
<pre tabindex="0"><code>use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!(&#34;{:?}&#34;, args);
}
</code></pre><ul>
<li>2.存储参数</li>
</ul>
<pre tabindex="0"><code>use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let filename = &amp;args[2];

    println!(&#34;Searching for {}&#34;, query);
    println!(&#34;In file {}&#34;, filename);
}
</code></pre><h4 id="152-读取文件">15.2 读取文件</h4>
<pre tabindex="0"><code>use std::env;
use std::fs;
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let filename = &amp;args[2];

    println!(&#34;Searching for {}&#34;, query);
    println!(&#34;In file {}&#34;, filename);

    let contents = fs::read_to_string(filename)
        .expect(&#34;Something went wrong reading the file&#34;);

    println!(&#34;With text:\n{}&#34;, contents);
}
</code></pre><h4 id="153-提高模块化和错误处理">15.3 提高模块化和错误处理</h4>
<p>lib.rs</p>
<pre tabindex="0"><code>use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
        if args.len() &lt; 3 {
            panic!(&#34;not enough arguments&#34;);
        }
        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.filename)?;

    println!(&#34;With text:\n{}&#34;, contents);

    Ok(())
}
</code></pre><p>main.rs</p>
<pre tabindex="0"><code>use std::env;

use std::process;
use minigrep::Config;


fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&#34;Problem parsing arguments: {}&#34;, err);
        process::exit(1);
    });

    println!(&#34;Searching for {}&#34;, config.query);
    println!(&#34;In file {}&#34;, config.filename);

    if let Err(e) = minigrep::run(config) {
        println!(&#34;Application error: {}&#34;, e);

        process::exit(1);
    }
}
</code></pre><h4 id="154-使用测试驱动开发开发库的功能">15.4 使用测试驱动开发开发库的功能</h4>
<pre tabindex="0"><code>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = &#34;duct&#34;;
        let contents = &#34;\
Rust:
safe, fast, productive.
Pick three.&#34;;

        assert_eq!(vec![&#34;safe, fast, productive.&#34;], search(query, contents));
    }
}
</code></pre><h4 id="155-使用环境变量">15.5 使用环境变量</h4>
<pre tabindex="0"><code>CASE_INSENSITIVE=1 cargo run to poem.txt
</code></pre><h4 id="156-将错误写出到标准输出">15.6 将错误写出到标准输出</h4>
<pre tabindex="0"><code>cargo run &gt; output.txt
</code></pre><p>使用<strong>eprintln!()</strong> 代替 <strong>println!()</strong>。</p>
<h3 id="16-函数式语言特性迭代器和闭包">16. 函数式语言特性：迭代器和闭包</h3>
<h4 id="161-创建闭包抽象行为">16.1 创建闭包抽象行为</h4>
<pre tabindex="0"><code>use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
    println!(&#34;calculating slowly...&#34;);
    thread::sleep(Duration::from_secs(2));
    intensity
}
</code></pre><h4 id="162-使用迭代器处理一系列项目">16.2 使用迭代器处理一系列项目</h4>
<pre tabindex="0"><code>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!(&#34;Got: {}&#34;, val);
    }
</code></pre><h4 id="163-改进io项目">16.3 改进I/O项目</h4>
<pre tabindex="0"><code>impl Config {
    pub fn new(mut args: env::Args) -&gt; Result&lt;Config, &amp;&#39;static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&#34;Didn&#39;t get a query string&#34;),
        };

        let filename = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&#34;Didn&#39;t get a file name&#34;),
        };

        let case_sensitive = env::var(&#34;CASE_INSENSITIVE&#34;).is_err();

        Ok(Config {
            query,
            filename,
            case_sensitive,
        })
    }
}
</code></pre><pre tabindex="0"><code>pub fn search&lt;&#39;a&gt;(query: &amp;str, contents: &amp;&#39;a str) -&gt; Vec&lt;&amp;&#39;a str&gt; {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
</code></pre><h4 id="164-比较性能循环与迭代器">16.4 比较性能：循环与迭代器</h4>
<p>闭包和迭代器是受函数式编程语言思想启发的 Rust 特性。它们有助于 Rust 以低级性能清晰表达高级思想的能力。闭包和迭代器的实现不会影响运行时性能。这是 Rust 努力提供零成本抽象目标的一部分。</p>
<h3 id="17-更多的关于cargo和cratesio">17. 更多的关于Cargo和Crates.io</h3>
<ul>
<li>通过发布配置文件自定义您的构建</li>
<li>在crates.io上发布库</li>
<li>使用工作区组织大型项目</li>
<li>从crates.io安装二进制文件</li>
<li>使用自定义命令扩展 Cargo</li>
</ul>
<h4 id="171-使用发布配置文件自定义构建">17.1 使用发布配置文件自定义构建</h4>
<p>Cargo 有两个主要配置文件：devCargo 在您运行时使用cargo build的release配置文件和Cargo 在您运行时使用的配置文件cargo build &ndash;release。该dev配置文件为开发定义了良好的默认值，并且该release配置文件具有用于发布构建的良好默认值。</p>
<pre tabindex="0"><code>$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
$ cargo build --release
    Finished release [optimized] target(s) in 0.0s
</code></pre><p>此构建输出中显示的dev和release表明编译器正在使用不同的配置文件。</p>
<p>文件名：Cargo.toml</p>
<pre tabindex="0"><code>[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre><p>该opt-level设置控制 Rust 将应用于您的代码的优化数量，范围为 0 到 3。应用更多优化会延长编译时间，因此如果您正在开发并经常编译您的代码，您将需要更快的编译，即使生成的代码运行速度较慢。这就是原因，默认opt-level的dev就是0。当您准备好发布代码时，最好花更多时间编译。您只会在发布模式下编译一次，但您将多次运行已编译的程序，因此发布模式会用更长的编译时间来换取运行速度更快的代码。这就是为什么默认opt-level的release配置文件3。</p>
<p>文件名：Cargo.toml</p>
<pre tabindex="0"><code>[profile.dev]
opt-level = 1
</code></pre><p>此代码覆盖 的默认设置0。现在，当我们运行时cargo build，Cargo 将使用dev配置文件的默认值加上我们对 opt-level. 因为我们设置opt-level为1，Cargo 将应用比默认更多的优化，但不会像在发布版本中那么多。</p>
<h4 id="172-将-crate-发布到-cratesio">17.2 将 Crate 发布到 Crates.io</h4>
<ul>
<li>
<ol>
<li>进行有用的文档评论</li>
</ol>
</li>
</ul>
<p>文档注释使用三个斜杠 ,///而不是两个，并且支持 Markdown 表示法来格式化文本。将文档注释放在他们正在记录的项目之前。</p>
<p>函数文档注释例子：</p>
<pre tabindex="0"><code>/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre><ul>
<li>
<ol start="2">
<li>设置 Crates.io 帐户</li>
</ol>
</li>
</ul>
<p>在发布任何 crate 之前，您需要在crates.io上创建一个帐户 并获取 API 令牌。为此，请访问crates.io 的主页并通过 GitHub 帐户登录。（GitHub 帐户目前是必需的，但该站点将来可能会支持其他创建帐户的方式。）登录后，请访问https://crates.io/me/ 上的帐户设置并检索您的帐户 API 密钥。然后cargo login使用您的 API 密钥运行命令，如下所示：</p>
<pre tabindex="0"><code>$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre><ul>
<li>3 将元数据添加到新的 Crate</li>
</ul>
<p>文件名：Cargo.toml</p>
<pre tabindex="0"><code>[package]
name = &#34;guessing_game&#34;
version = &#34;0.1.0&#34;
authors = [&#34;Your Name &lt;you@example.com&gt;&#34;]
edition = &#34;2018&#34;
description = &#34;A fun game where you guess what number the computer has chosen.&#34;
license = &#34;MIT OR Apache-2.0&#34;
</code></pre><pre tabindex="0"><code>$ cargo publish
</code></pre><ul>
<li>
<ol start="4">
<li>发布到 Crates.io</li>
</ol>
</li>
</ul>
<p>cargo publish再次运行命令。现在应该成功了：</p>
<pre tabindex="0"><code>$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre><ul>
<li>
<ol start="5">
<li>从 Crates.io 中删除版本 cargo yank</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>$ cargo yank --vers 1.0.1
</code></pre><pre tabindex="0"><code>$ cargo yank --vers 1.0.1 --undo
</code></pre><h4 id="173-cargo工作区域">17.3 Cargo工作区域</h4>
<ul>
<li>
<ol>
<li>创建工作区域</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>$ mkdir add
$ cd add
</code></pre><pre tabindex="0"><code>[workspace]

members = [
    &#34;adder&#34;,
]
</code></pre><pre tabindex="0"><code>$ cargo new adder
     Created binary (application) `adder` package     
</code></pre><p>执行cargo builh后的文件目录如下：</p>
<pre tabindex="0"><code>├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre><ul>
<li>
<ol start="2">
<li>在工作区域中创建第二个包</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>[workspace]

members = [
    &#34;adder&#34;,
    &#34;add-one&#34;,
]
</code></pre><pre tabindex="0"><code>$ cargo new add-one --lib
     Created library `add-one` package
</code></pre><pre tabindex="0"><code>├── Cargo.lock
├── Cargo.toml
├── add-one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre><ul>
<li>
<ol start="3">
<li>在工作区域中添加依赖包</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>[dependencies]
rand = &#34;0.8.3&#34;
</code></pre><ul>
<li>
<ol start="4">
<li>在工作区域中添加测试</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
</code></pre><h4 id="174-从-cratesio-安装二进制文件-cargo-install">17.4 从 Crates.io 安装二进制文件 cargo install</h4>
<p>该cargo install命令允许您在本地安装和使用二进制包。安装的所有二进制文件cargo install都存储在安装根目录的bin文件夹中。</p>
<pre tabindex="0"><code>$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v11.0.2
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v11.0.2
--snip--
   Compiling ripgrep v11.0.2
    Finished release [optimized + debuginfo] target(s) in 3m 10s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v11.0.2` (executable `rg`)
</code></pre><h4 id="175-使用自定义命令扩展-cargo">17.5 使用自定义命令扩展 Cargo</h4>
<pre tabindex="0"><code>cargo --list
</code></pre><h3 id="18-智能指针">18. 智能指针</h3>
<h4 id="181-使用bt指向堆栈数据">18.1 使用B<!-- raw HTML omitted -->指向堆栈数据</h4>
<pre tabindex="0"><code>fn main() {
    let b = Box::new(5);
    println!(&#34;b = {}&#34;, b);
}
</code></pre><h4 id="182-将智能指针视为具有dereftrait-的常规引用">18.2 将智能指针视为具有Dereftrait 的常规引用</h4>
<pre tabindex="0"><code>fn main() {
    let m = MyBox::new(String::from(&#34;Rust&#34;));
    hello(&amp;m);
}
</code></pre><h4 id="183-使用drop特征在清理时运行代码">18.3 使用Drop特征在清理时运行代码</h4>
<pre tabindex="0"><code>struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!(&#34;Dropping CustomSmartPointer with data `{}`!&#34;, self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from(&#34;my stuff&#34;),
    };
    let d = CustomSmartPointer {
        data: String::from(&#34;other stuff&#34;),
    };
    println!(&#34;CustomSmartPointers created.&#34;);
}
</code></pre><p>尽早删除一个值 std::mem::drop。</p>
<pre tabindex="0"><code>fn main() {
    let c = CustomSmartPointer {
        data: String::from(&#34;some data&#34;),
    };
    println!(&#34;CustomSmartPointer created.&#34;);
    drop(c);
    println!(&#34;CustomSmartPointer dropped before the end of main.&#34;);
}
</code></pre><h4 id="184-使用rt进行智能指针计数">18.4 使用R<!-- raw HTML omitted -->进行智能指针计数</h4>
<pre tabindex="0"><code>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&#34;count after creating a = {}&#34;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!(&#34;count after creating b = {}&#34;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!(&#34;count after creating c = {}&#34;, Rc::strong_count(&amp;a));
    }
    println!(&#34;count after c goes out of scope = {}&#34;, Rc::strong_count(&amp;a));
}
</code></pre><h4 id="185-refcellt-和内部可变性模式">18.5 RefCell<!-- raw HTML omitted --> 和内部可变性模式</h4>
<pre tabindex="0"><code>#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!(&#34;a after = {:?}&#34;, a);
    println!(&#34;b after = {:?}&#34;, b);
    println!(&#34;c after = {:?}&#34;, c);
}
</code></pre><h4 id="186-引用可引发内存溢出">18.6 引用可引发内存溢出</h4>
<pre tabindex="0"><code>n main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        &#34;leaf strong = {}, weak = {}&#34;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            &#34;branch strong = {}, weak = {}&#34;,
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            &#34;leaf strong = {}, weak = {}&#34;,
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!(&#34;leaf parent = {:?}&#34;, leaf.parent.borrow().upgrade());
    println!(
        &#34;leaf strong = {}, weak = {}&#34;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}
</code></pre><h3 id="19-并发">19. 并发</h3>
<ul>
<li>如何创建线程同时运行多段代码</li>
<li>消息传递并发，其中通道在线程之间发送消息</li>
<li>共享状态并发，其中多个线程可以访问某些数据</li>
<li>Sync和Send特征，延伸Rust的并发保证由标准库提供的用户定义的类型以及类型</li>
</ul>
<h4 id="191-使用线程运行代码">19.1 使用线程运行代码</h4>
<ul>
<li>1.使用spawn创建线程</li>
</ul>
<pre tabindex="0"><code>use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&#34;hi number {} from the spawned thread!&#34;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&#34;hi number {} from the main thread!&#34;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre><ul>
<li>2.等待线程结束使用join句柄</li>
</ul>
<pre tabindex="0"><code>use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&#34;hi number {} from the spawned thread!&#34;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&#34;hi number {} from the main thread!&#34;, i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
</code></pre><p>如果将执行语句改变，结果也将发生改变：</p>
<pre tabindex="0"><code>use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&#34;hi number {} from the spawned thread!&#34;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!(&#34;hi number {} from the main thread!&#34;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre><ul>
<li>
<ol start="3">
<li>在线程中使用move</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&#34;Here&#39;s a vector: {:?}&#34;, v);
    });

    handle.join().unwrap();
}
</code></pre><h4 id="192-线程直接传递数据">19.2 线程直接传递数据</h4>
<pre tabindex="0"><code>use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&#34;hi&#34;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!(&#34;Got: {}&#34;, received);
}
</code></pre><p>管道和所有权转移</p>
<pre tabindex="0"><code>use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from(&#34;hi&#34;),
            String::from(&#34;from&#34;),
            String::from(&#34;the&#34;),
            String::from(&#34;thread&#34;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&#34;Got: {}&#34;, received);
    }
}
</code></pre><h4 id="193-共享状态并发">19.3 共享状态并发</h4>
<pre tabindex="0"><code>use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&#34;Result: {}&#34;, *counter.lock().unwrap());
}
</code></pre><h4 id="194-具有sync和send特征的可扩展并发">19.4 具有Sync和Send特征的可扩展并发</h4>
<p>所述Send标记物性状表示实施类型的值的所有权 Send可以在线程之间转移。几乎所有的 Rust 类型都是Send，但也有一些例外，包括Rc<!-- raw HTML omitted -->：这不可能是Send因为如果你克隆了一个Rc<!-- raw HTML omitted -->值并试图将克隆的所有权转移到另一个线程，两个线程可能会同时更新引用计数。出于这个原因，Rc<!-- raw HTML omitted -->实现用于单线程情况，在这种情况下，您不想支付线程安全的性能损失。</p>
<h3 id="20-rust的面向对象特性">20. Rust的面向对象特性</h3>
<p>将展示如何在 Rust 中实现面向对象的设计模式，并讨论这样做与使用 Rust 的一些优势来实现解决方案之间的权衡。</p>
<h4 id="201-面向对象语言特点">20.1 面向对象语言特点</h4>
<pre tabindex="0"><code>pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}

impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            }
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
</code></pre><h4 id="202-使用允许不同类型值的特征对象">20.2 使用允许不同类型值的特征对象</h4>
<pre tabindex="0"><code>pub trait Draw {
    fn draw(&amp;self);
}
</code></pre><pre tabindex="0"><code>pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}
</code></pre><pre tabindex="0"><code>impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
</code></pre><pre tabindex="0"><code>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
where
    T: Draw,
{
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
</code></pre><pre tabindex="0"><code>pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // code to actually draw a button
    }
}
</code></pre><pre tabindex="0"><code>use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // code to actually draw a select box
    }
}
</code></pre><pre tabindex="0"><code>use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from(&#34;Yes&#34;),
                    String::from(&#34;Maybe&#34;),
                    String::from(&#34;No&#34;),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from(&#34;OK&#34;),
            }),
        ],
    };

    screen.run();
}
</code></pre><h4 id="203-实现面向对象设计">20.3 实现面向对象设计</h4>
<pre tabindex="0"><code>pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
</code></pre><h3 id="21-模式和匹配">21. 模式和匹配</h3>
<ul>
<li>Literals</li>
<li>Destructured arrays, enums, structs, or tuples</li>
<li>Variables</li>
<li>Wildcards</li>
<li>Placeholders</li>
</ul>
<h4 id="211-所有的地方模式都可以使用">21.1 所有的地方模式都可以使用</h4>
<ul>
<li>
<ol>
<li>match</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre><ul>
<li>
<ol start="2">
<li>条件if let表达式</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = &#34;34&#34;.parse();

    if let Some(color) = favorite_color {
        println!(&#34;Using your favorite color, {}, as the background&#34;, color);
    } else if is_tuesday {
        println!(&#34;Tuesday is green day!&#34;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!(&#34;Using purple as the background color&#34;);
        } else {
            println!(&#34;Using orange as the background color&#34;);
        }
    } else {
        println!(&#34;Using blue as the background color&#34;);
    }
}
</code></pre><ul>
<li>
<ol start="3">
<li>while let 条件循环</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(top) = stack.pop() {
        println!(&#34;{}&#34;, top);
    }
</code></pre><ul>
<li>
<ol start="4">
<li>for 循环</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>    let v = vec![&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];

    for (index, value) in v.iter().enumerate() {
        println!(&#34;{} is at index {}&#34;, value, index);
    }
</code></pre><ul>
<li>
<ol start="5">
<li>let 声明</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>let x = 5;
</code></pre><pre tabindex="0"><code>let PATTERN = EXPRESSION;
</code></pre><pre tabindex="0"><code>let (x, y, z) = (1, 2, 3);
</code></pre><ul>
<li>
<ol start="6">
<li>功能参数</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>fn foo(x: i32) {
    // code goes here
}
</code></pre><h4 id="212-匹配和不匹配">21.2 匹配和不匹配</h4>
<pre tabindex="0"><code>if let Some(x) = some_option_value {
        println!(&#34;{}&#34;, x);
    }
</code></pre><pre tabindex="0"><code>if let x = 5 {
        println!(&#34;{}&#34;, x);
    };
</code></pre><h4 id="203-模式语法">20.3 模式语法</h4>
<ul>
<li>
<ol>
<li>匹配文字</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code> let x = 1;

    match x {
        1 =&gt; println!(&#34;one&#34;),
        2 =&gt; println!(&#34;two&#34;),
        3 =&gt; println!(&#34;three&#34;),
        _ =&gt; println!(&#34;anything&#34;),
    }
</code></pre><ul>
<li>
<ol start="2">
<li>匹配命名变量</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&#34;Got 50&#34;),
        Some(y) =&gt; println!(&#34;Matched, y = {:?}&#34;, y),
        _ =&gt; println!(&#34;Default case, x = {:?}&#34;, x),
    }

    println!(&#34;at the end: x = {:?}, y = {:?}&#34;, x, y);
</code></pre><ul>
<li>
<ol start="3">
<li>多种模式</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>let x = 1;

    match x {
        1 | 2 =&gt; println!(&#34;one or two&#34;),
        3 =&gt; println!(&#34;three&#34;),
        _ =&gt; println!(&#34;anything&#34;),
    }
</code></pre><ul>
<li>
<ol start="4">
<li>匹配值的范围 ..=</li>
</ol>
</li>
</ul>
<p>数字：</p>
<pre tabindex="0"><code>    let x = 5;

    match x {
        1..=5 =&gt; println!(&#34;one through five&#34;),
        _ =&gt; println!(&#34;something else&#34;),
    }
</code></pre><p>字符：</p>
<pre tabindex="0"><code>    let x = &#39;c&#39;;

    match x {
        &#39;a&#39;..=&#39;j&#39; =&gt; println!(&#34;early ASCII letter&#34;),
        &#39;k&#39;..=&#39;z&#39; =&gt; println!(&#34;late ASCII letter&#34;),
        _ =&gt; println!(&#34;something else&#34;),
    }
</code></pre><ul>
<li>
<ol start="5">
<li>解构以打破价值观</li>
</ol>
</li>
</ul>
<p>解构结构:</p>
<pre tabindex="0"><code>struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);

    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&#34;On the x axis at {}&#34;, x),
        Point { x: 0, y } =&gt; println!(&#34;On the y axis at {}&#34;, y),
        Point { x, y } =&gt; println!(&#34;On neither axis: ({}, {})&#34;, x, y),
    }
}
</code></pre><p>解构枚举:</p>
<pre tabindex="0"><code>enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!(&#34;The Quit variant has no data to destructure.&#34;)
        }
        Message::Move { x, y } =&gt; {
            println!(
                &#34;Move in the x direction {} and in the y direction {}&#34;,
                x, y
            );
        }
        Message::Write(text) =&gt; println!(&#34;Text message: {}&#34;, text),
        Message::ChangeColor(r, g, b) =&gt; println!(
            &#34;Change the color to red {}, green {}, and blue {}&#34;,
            r, g, b
        ),
    }
}
</code></pre><p>解构嵌套结构和枚举:</p>
<pre tabindex="0"><code>enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; println!(
            &#34;Change the color to red {}, green {}, and blue {}&#34;,
            r, g, b
        ),
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; println!(
            &#34;Change the color to hue {}, saturation {}, and value {}&#34;,
            h, s, v
        ),
        _ =&gt; (),
    }
}
</code></pre><p>解构结构和元组:</p>
<pre tabindex="0"><code> let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
</code></pre><ul>
<li>
<ol start="6">
<li>忽略模式中的值</li>
</ol>
</li>
</ul>
<p>忽略整个值 _</p>
<pre tabindex="0"><code>fn foo(_: i32, y: i32) {
    println!(&#34;This code only uses the y parameter: {}&#34;, y);
}

fn main() {
    foo(3, 4);
}
</code></pre><p>使用嵌套忽略部分值 _</p>
<pre tabindex="0"><code>let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!(&#34;Can&#39;t overwrite an existing customized value&#34;);
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!(&#34;setting is {:?}&#34;, setting_value);
</code></pre><pre tabindex="0"><code>let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!(&#34;Some numbers: {}, {}, {}&#34;, first, third, fifth)
        }
    }
</code></pre><p>忽略一个未使用的变量，以它的名字开头 _</p>
<pre tabindex="0"><code>fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre><p>忽略值的剩余部分 ..</p>
<pre tabindex="0"><code>struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!(&#34;x is {}&#34;, x),
    }
</code></pre><p>如何使用..元组</p>
<pre tabindex="0"><code>fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&#34;Some numbers: {}, {}&#34;, first, last);
        }
    }
}
</code></pre><p>试图以..一种模棱两可的方式使用的错误使用：</p>
<pre tabindex="0"><code>fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&#34;Some numbers: {}&#34;, second)
        },
    }
}
</code></pre><p>带有匹配守卫的额外条件</p>
<pre tabindex="0"><code>    let num = Some(4);

    match num {
        Some(x) if x &lt; 5 =&gt; println!(&#34;less than five: {}&#34;, x),
        Some(x) =&gt; println!(&#34;{}&#34;, x),
        None =&gt; (),
    }
</code></pre><p>@ 绑定</p>
<pre tabindex="0"><code> enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!(&#34;Found an id in range: {}&#34;, id_variable),
        Message::Hello { id: 10..=12 } =&gt; {
            println!(&#34;Found an id in another range&#34;)
        }
        Message::Hello { id } =&gt; println!(&#34;Found some other id: {}&#34;, id),
    }
</code></pre><h3 id="22-高级功能">22 高级功能</h3>
<ul>
<li>不安全的Rust</li>
<li>高级特性</li>
<li>高级类型</li>
<li>高级函数和闭包</li>
<li>宏指令</li>
</ul>
<h4 id="221-不安全的rust">22.1 不安全的Rust</h4>
<pre tabindex="0"><code>unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}

fn main() {}
</code></pre><h4 id="222-高级特性">22.2 高级特性</h4>
<pre tabindex="0"><code>use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &#34;[{}]&#34;, self.0.join(&#34;, &#34;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&#34;hello&#34;), String::from(&#34;world&#34;)]);
    println!(&#34;w = {}&#34;, w);
}
</code></pre><h4 id="223-高级类型">22.3 高级类型</h4>
<ul>
<li>
<ol>
<li>创建匿名类型</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!(&#34;x + y = {}&#34;, x + y);
</code></pre><ul>
<li>
<ol start="2">
<li>从未使用类型和返回值</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&#34;called `Option::unwrap()` on a `None` value&#34;),
        }
    }
}
</code></pre><h4 id="224-高级函数和闭包">22.4 高级函数和闭包</h4>
<pre tabindex="0"><code>fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!(&#34;The answer is: {}&#34;, answer);
}
</code></pre><pre tabindex="0"><code>fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
</code></pre><h4 id="225-宏指令">22.5 宏指令</h4>
<p>展示一个简单的定义vec!宏</p>
<pre tabindex="0"><code>#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
</code></pre><h3 id="23-最终的项目创建一个多线程的web服务">23 最终的项目：创建一个多线程的Web服务</h3>
<ul>
<li>
<p>学习一点TCP和HTTP</p>
</li>
<li>
<p>TCP的Stocket监听</p>
</li>
<li>
<p>在HTTP请求中处理一个数字</p>
</li>
<li>
<p>创建一个HTTP反馈</p>
</li>
<li>
<p>改进Web服务提供线程池功能</p>
</li>
</ul>
<h4 id="231-创建一个单线程的web服务">23.1 创建一个单线程的Web服务</h4>
<pre tabindex="0"><code>use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&#34;127.0.0.1:7878&#34;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!(&#34;Connection established!&#34;);
    }
}
</code></pre><h4 id="232-将单线程转变为多线程">23.2 将单线程转变为多线程</h4>
<pre tabindex="0"><code>
use std::thread;
use std::time::Duration;
// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--

    let get = b&#34;GET / HTTP/1.1\r\n&#34;;
    let sleep = b&#34;GET /sleep HTTP/1.1\r\n&#34;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&#34;HTTP/1.1 200 OK&#34;, &#34;hello.html&#34;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&#34;HTTP/1.1 200 OK&#34;, &#34;hello.html&#34;)
    } else {
        (&#34;HTTP/1.1 404 NOT FOUND&#34;, &#34;404.html&#34;)
    };

    // --snip--
}
</code></pre><p>创建线程池对象：</p>
<pre tabindex="0"><code>use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --snip--
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}
</code></pre><h4 id="233-跟踪和清理工作">23.3 跟踪和清理工作</h4>
<pre tabindex="0"><code>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre><p>清理：</p>
<pre tabindex="0"><code>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&#34;Shutting down worker {}&#34;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</code></pre><p>看完了，但是真正的使用上，感觉还需要一段时间呀！</p>
<blockquote>
<p>路漫漫及其修远，吾将上下而求索。</p>
</blockquote>
<p>2021年06月15日</p>

            </div>
        </div>
    </div>
</section>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-123-45', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>
    
  
  <script type="text/javascript">
    hljs.initHighlightingOnLoad();
  </script>





</body>
</html>

