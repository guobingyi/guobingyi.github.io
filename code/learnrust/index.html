<!DOCTYPE html>
<html lang="zh-cn">

<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">
<meta name="author" content="Arthur Dent">
<meta name="description" content="Rust å­¦ä¹ ç¬”è®° è‡ªä»åœ¨å·¥ä½œæ˜¯ä½¿ç”¨äº†Goè¯­è¨€åï¼Œå°±ä¸æ–­çš„æ‰“ç ´åŸæ¥çš„æ¨¡å¼ï¼Œæƒ³ä»€ä¹ˆéƒ½ç”¨Goæ¥å®ç°ï¼Œå¯æƒœæœ‰äº›ä¸œè¥¿ï¼Œç‰¹åˆ«æ˜¯Windowsä¸‹çš„çª—å£ç¨‹åºï¼Œå°±æ— èƒ½ä¸ºåŠ›äº†ï¼Œå…¶ä»–çš„å¥½åƒéƒ½å¯ä»¥è¯•ä¸€è¯•ã€‚å› ä¸ºå…³æ³¨Goï¼Œæ‰€ä»¥Nodeçš„ä½œè€…æƒ³é‡æ–°å†™Nodeçš„æ—¶å€™ï¼Œé€‰æ‹©äº†Goï¼Œæœ€åå±…ç„¶æ¢æˆäº†Rustã€‚è¿™ä¸å¾—ä¸è®©æˆ‘å¯¹è¿™é—¨è¯­è¨€æœ‰äº†æ–°çš„çœ‹æ³•ï¼Œç‰¹åˆ«æ˜¯å¾®è½¯å’ŒGoogleéƒ½è¦æ¨Rustçš„æ—¶å€™ï¼Œæˆ‘æ”¾å¼ƒäº†æˆ‘åŸæ¥å¯¹è¿™é—¨è¯­è¨€çš„åè§ï¼Œé‡æ–°ã€è®¤çœŸçš„å­¦ä¹ ä¸€éï¼Œè®©æˆ‘çœ‹çœ‹åˆ°åº•æ˜¯ä»€ä¹ˆè®©å®ƒå—åˆ°é‚£ä¹ˆå¤šäººçš„å…³æ³¨ã€‚
å‰è¨€ ç³»ç»Ÿçº§åˆ«çš„è¯­è¨€ï¼Œå¯ä»¥å’ŒC/C&#43;&#43;æŠ—è¡¡ï¼Ÿç›®æ ‡å°±æ˜¯ä¸ºäº†å–ä»£C&#43;&#43;ã€‚
ä»‹ç» Rustè¯­è¨€èƒ½å¤Ÿç¼–å†™é€Ÿåº¦æ›´å¿«ï¼Œæ›´åŠ å¯é çš„è½¯ä»¶ã€‚
å­¦ä¹ ç¬”è®°ä¸º1.52.1ç‰ˆæœ¬ï¼Œå¦‚æœä½ æ¥æ™šäº†ï¼Œæœ€å¥½å‚è€ƒ æœ€æ–°æ–‡æ¡£ æ¥è¿›è¡Œå­¦ä¹ ã€‚ä½ æ‡‚çš„ï½ï½
0x01 å¼€å§‹ 1.ç›®æ ‡ å®‰è£… å†™ä¸ªè¾“å‡ºhello worldçš„ç¨‹åº ä½¿ç”¨cargoå·¥å…·æ¥æ„å»ºç³»ç»Ÿ 2 å®‰è£… 2.1 å®‰è£… å…¶å®åœ¨è‹¹æœç”µè„‘ä¸Šï¼Œèƒ½ç”¨brewå®‰è£…çš„ï¼Œæˆ‘ä¸€èˆ¬éƒ½ä¼šä½¿ç”¨ã€‚å¯æƒœï¼ŒRustæ¨èçš„æœ€ä½³æ–¹å¼ï¼Œå¹¶ä¸æ˜¯ã€‚ğŸ˜Š
æ‰€ä»¥ï¼Œä½¿ç”¨Rustçš„å®‰è£…æ–¹å¼ï¼Œæœ€ä½³ã€‚
$ curl --proto &#39;=https&#39; --tlsv1.2 https://sh.rustup.rs -sSf | sh å®‰è£…æˆåŠŸåï¼Œå°†åœ¨å‘½ä»¤ç«¯è¾“å‡ºï¼š
Rust is installed now. Great! 2.2 æ›´æ–° $ rustup update 2.3 åˆ é™¤ $ rustup self uninstall ä½¿ç”¨äº†è®¸å¤šè¯­è¨€åï¼Œè¿™ä¸ªæ˜¯å‘ç°æœ€è´´å¿ƒçš„ã€‚
2.4 ç‰ˆæœ¬æŸ¥çœ‹ $ rustc --version 2.5 é˜…è¯»æœ¬åœ°æ–‡æ¡£ rustup doc 3. Hello,World! 3.1 åˆ›å»ºé¡¹ç›®è·¯å¾„ $ mkdir ~/projects $ cd ~/projects $ mkdir hello_world $ cd hello_world 3.">

<meta property="og:title" content="LearnRust" />
<meta property="og:description" content="Rust å­¦ä¹ ç¬”è®° è‡ªä»åœ¨å·¥ä½œæ˜¯ä½¿ç”¨äº†Goè¯­è¨€åï¼Œå°±ä¸æ–­çš„æ‰“ç ´åŸæ¥çš„æ¨¡å¼ï¼Œæƒ³ä»€ä¹ˆéƒ½ç”¨Goæ¥å®ç°ï¼Œå¯æƒœæœ‰äº›ä¸œè¥¿ï¼Œç‰¹åˆ«æ˜¯Windowsä¸‹çš„çª—å£ç¨‹åºï¼Œå°±æ— èƒ½ä¸ºåŠ›äº†ï¼Œå…¶ä»–çš„å¥½åƒéƒ½å¯ä»¥è¯•ä¸€è¯•ã€‚å› ä¸ºå…³æ³¨Goï¼Œæ‰€ä»¥Nodeçš„ä½œè€…æƒ³é‡æ–°å†™Nodeçš„æ—¶å€™ï¼Œé€‰æ‹©äº†Goï¼Œæœ€åå±…ç„¶æ¢æˆäº†Rustã€‚è¿™ä¸å¾—ä¸è®©æˆ‘å¯¹è¿™é—¨è¯­è¨€æœ‰äº†æ–°çš„çœ‹æ³•ï¼Œç‰¹åˆ«æ˜¯å¾®è½¯å’ŒGoogleéƒ½è¦æ¨Rustçš„æ—¶å€™ï¼Œæˆ‘æ”¾å¼ƒäº†æˆ‘åŸæ¥å¯¹è¿™é—¨è¯­è¨€çš„åè§ï¼Œé‡æ–°ã€è®¤çœŸçš„å­¦ä¹ ä¸€éï¼Œè®©æˆ‘çœ‹çœ‹åˆ°åº•æ˜¯ä»€ä¹ˆè®©å®ƒå—åˆ°é‚£ä¹ˆå¤šäººçš„å…³æ³¨ã€‚
å‰è¨€ ç³»ç»Ÿçº§åˆ«çš„è¯­è¨€ï¼Œå¯ä»¥å’ŒC/C&#43;&#43;æŠ—è¡¡ï¼Ÿç›®æ ‡å°±æ˜¯ä¸ºäº†å–ä»£C&#43;&#43;ã€‚
ä»‹ç» Rustè¯­è¨€èƒ½å¤Ÿç¼–å†™é€Ÿåº¦æ›´å¿«ï¼Œæ›´åŠ å¯é çš„è½¯ä»¶ã€‚
å­¦ä¹ ç¬”è®°ä¸º1.52.1ç‰ˆæœ¬ï¼Œå¦‚æœä½ æ¥æ™šäº†ï¼Œæœ€å¥½å‚è€ƒ æœ€æ–°æ–‡æ¡£ æ¥è¿›è¡Œå­¦ä¹ ã€‚ä½ æ‡‚çš„ï½ï½
0x01 å¼€å§‹ 1.ç›®æ ‡ å®‰è£… å†™ä¸ªè¾“å‡ºhello worldçš„ç¨‹åº ä½¿ç”¨cargoå·¥å…·æ¥æ„å»ºç³»ç»Ÿ 2 å®‰è£… 2.1 å®‰è£… å…¶å®åœ¨è‹¹æœç”µè„‘ä¸Šï¼Œèƒ½ç”¨brewå®‰è£…çš„ï¼Œæˆ‘ä¸€èˆ¬éƒ½ä¼šä½¿ç”¨ã€‚å¯æƒœï¼ŒRustæ¨èçš„æœ€ä½³æ–¹å¼ï¼Œå¹¶ä¸æ˜¯ã€‚ğŸ˜Š
æ‰€ä»¥ï¼Œä½¿ç”¨Rustçš„å®‰è£…æ–¹å¼ï¼Œæœ€ä½³ã€‚
$ curl --proto &#39;=https&#39; --tlsv1.2 https://sh.rustup.rs -sSf | sh å®‰è£…æˆåŠŸåï¼Œå°†åœ¨å‘½ä»¤ç«¯è¾“å‡ºï¼š
Rust is installed now. Great! 2.2 æ›´æ–° $ rustup update 2.3 åˆ é™¤ $ rustup self uninstall ä½¿ç”¨äº†è®¸å¤šè¯­è¨€åï¼Œè¿™ä¸ªæ˜¯å‘ç°æœ€è´´å¿ƒçš„ã€‚
2.4 ç‰ˆæœ¬æŸ¥çœ‹ $ rustc --version 2.5 é˜…è¯»æœ¬åœ°æ–‡æ¡£ rustup doc 3. Hello,World! 3.1 åˆ›å»ºé¡¹ç›®è·¯å¾„ $ mkdir ~/projects $ cd ~/projects $ mkdir hello_world $ cd hello_world 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://guobingyi.github.io/code/learnrust/" /><meta property="article:section" content="code" />
<meta property="article:published_time" content="2021-05-29T11:20:30+08:00" />
<meta property="article:modified_time" content="2021-05-29T11:20:30+08:00" />



<title>


     LearnRust 

</title>
<link rel="canonical" href="https://guobingyi.github.io/code/learnrust/">







  
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/default.min.css">
  




<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Ubuntu+Mono:400,400i,700,700i|Raleway:500">



    
    <link rel="stylesheet" href="https://guobingyi.github.io/css/reset.css?t=2022-06-22%2016%3a53%3a21.256012%20%2b0800%20CST%20m%3d%2b4.545856855">
    <link rel="stylesheet" href="https://guobingyi.github.io/css/pygments.css?t=2022-06-22%2016%3a53%3a21.256012%20%2b0800%20CST%20m%3d%2b4.545856855">
    <link rel="stylesheet" href="https://guobingyi.github.io/css/main.css?t=2022-06-22%2016%3a53%3a21.256012%20%2b0800%20CST%20m%3d%2b4.545856855">
    
        <link rel="stylesheet" href="https://guobingyi.github.io/css/override.css?t=2022-06-22%2016%3a53%3a21.256012%20%2b0800%20CST%20m%3d%2b4.545856855">
    




<link rel="shortcut icon"

    href="https://guobingyi.github.io/img/leaf.ico"

>










</head>


<body lang="en">

<section class="header">
    <div class="container">
        <div class="content">
            
                
                
                
                
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                
                <a href="https://guobingyi.github.io/"><img class="avatar" src="https://guobingyi.github.io/img/profile.png" srcset="https://guobingyi.github.io/img/profile.png 1x"></a>
            
            <a href="https://guobingyi.github.io/"><div class="name">Arthur Dent</div></a>
            
            <nav>
                <ul>
                    
                        
                        <li class="nav-blog"><a href="https://guobingyi.github.io/blog/"><span>Blog</span></a></li>
                    
                        
                        <li class="nav-movie"><a href="https://guobingyi.github.io/movie/"><span>Movie</span></a></li>
                    
                        
                        <li class="nav-code"><a href="https://guobingyi.github.io/code/"><span>Code</span></a></li>
                    
                        
                        <li class="nav-life"><a href="https://guobingyi.github.io/life/"><span>Life</span></a></li>
                    
                        
                        <li class="nav-opensource"><a href="https://guobingyi.github.io/opensource/"><span>OpenSource</span></a></li>
                    
                        
                        <li class="nav-emacs"><a href="https://guobingyi.github.io/emacs/"><span>Emacs</span></a></li>
                    
                        
                        <li class="nav-mac"><a href="https://guobingyi.github.io/mac/"><span>Mac</span></a></li>
                    
                        
                        <li class="nav-book"><a href="https://guobingyi.github.io/book/"><span>Book</span></a></li>
                    
                        
                        <li class="nav-about"><a href="https://guobingyi.github.io/about/"><span>About</span></a></li>
                    
                </ul>
            </nav>
        </div>
    </div>
</section>

<section class="icons">
    <div class="container">
        <div class="content">
        
            <a href="//github.com/guobingyi" target="_blank" rel="noopener"><img class="icon" src="https://guobingyi.github.io/img/github.svg" alt="github" /></a>
        

        

        

	

        

        

        

        

        

        

        

        

        
            <a href="mailto:likemi7@126.com"><img class="icon" src="https://guobingyi.github.io/img/email.svg" alt="email" /></a>
        

        
        
        

        
        </div>
    </div>
</section>

<section class="main">
    <div class="container">
        <div class="content">
            <div class="page-heading">

    LearnRust

</div>

            <div class="markdown">
                <h1 id="rust-å­¦ä¹ ç¬”è®°">Rust å­¦ä¹ ç¬”è®°</h1>
<blockquote>
<p>è‡ªä»åœ¨å·¥ä½œæ˜¯ä½¿ç”¨äº†Goè¯­è¨€åï¼Œå°±ä¸æ–­çš„æ‰“ç ´åŸæ¥çš„æ¨¡å¼ï¼Œæƒ³ä»€ä¹ˆéƒ½ç”¨Goæ¥å®ç°ï¼Œå¯æƒœæœ‰äº›ä¸œè¥¿ï¼Œç‰¹åˆ«æ˜¯Windowsä¸‹çš„çª—å£ç¨‹åºï¼Œå°±æ— èƒ½ä¸ºåŠ›äº†ï¼Œå…¶ä»–çš„å¥½åƒéƒ½å¯ä»¥è¯•ä¸€è¯•ã€‚å› ä¸ºå…³æ³¨Goï¼Œæ‰€ä»¥Nodeçš„ä½œè€…æƒ³é‡æ–°å†™Nodeçš„æ—¶å€™ï¼Œé€‰æ‹©äº†Goï¼Œæœ€åå±…ç„¶æ¢æˆäº†Rustã€‚è¿™ä¸å¾—ä¸è®©æˆ‘å¯¹è¿™é—¨è¯­è¨€æœ‰äº†æ–°çš„çœ‹æ³•ï¼Œç‰¹åˆ«æ˜¯å¾®è½¯å’ŒGoogleéƒ½è¦æ¨Rustçš„æ—¶å€™ï¼Œæˆ‘æ”¾å¼ƒäº†æˆ‘åŸæ¥å¯¹è¿™é—¨è¯­è¨€çš„åè§ï¼Œé‡æ–°ã€è®¤çœŸçš„å­¦ä¹ ä¸€éï¼Œè®©æˆ‘çœ‹çœ‹åˆ°åº•æ˜¯ä»€ä¹ˆè®©å®ƒå—åˆ°é‚£ä¹ˆå¤šäººçš„å…³æ³¨ã€‚</p>
</blockquote>
<h2 id="å‰è¨€">å‰è¨€</h2>
<p>ç³»ç»Ÿçº§åˆ«çš„è¯­è¨€ï¼Œå¯ä»¥å’ŒC/C++æŠ—è¡¡ï¼Ÿç›®æ ‡å°±æ˜¯ä¸ºäº†å–ä»£C++ã€‚</p>
<h2 id="ä»‹ç»">ä»‹ç»</h2>
<p>Rustè¯­è¨€èƒ½å¤Ÿç¼–å†™é€Ÿåº¦æ›´å¿«ï¼Œæ›´åŠ å¯é çš„è½¯ä»¶ã€‚</p>
<p>å­¦ä¹ ç¬”è®°ä¸º1.52.1ç‰ˆæœ¬ï¼Œå¦‚æœä½ æ¥æ™šäº†ï¼Œæœ€å¥½å‚è€ƒ
<a href="https://doc.rust-lang.org/book/">æœ€æ–°æ–‡æ¡£</a> æ¥è¿›è¡Œå­¦ä¹ ã€‚ä½ æ‡‚çš„ï½ï½</p>
<h2 id="0x01-å¼€å§‹">0x01 å¼€å§‹</h2>
<h3 id="1ç›®æ ‡">1.ç›®æ ‡</h3>
<ul>
<li>å®‰è£…</li>
<li>å†™ä¸ªè¾“å‡ºhello worldçš„ç¨‹åº</li>
<li>ä½¿ç”¨cargoå·¥å…·æ¥æ„å»ºç³»ç»Ÿ</li>
</ul>
<h3 id="2-å®‰è£…">2 å®‰è£…</h3>
<h4 id="21-å®‰è£…">2.1 å®‰è£…</h4>
<p>å…¶å®åœ¨è‹¹æœç”µè„‘ä¸Šï¼Œèƒ½ç”¨brewå®‰è£…çš„ï¼Œæˆ‘ä¸€èˆ¬éƒ½ä¼šä½¿ç”¨ã€‚å¯æƒœï¼ŒRustæ¨èçš„æœ€ä½³æ–¹å¼ï¼Œå¹¶ä¸æ˜¯ã€‚ğŸ˜Š</p>
<p>æ‰€ä»¥ï¼Œä½¿ç”¨Rustçš„å®‰è£…æ–¹å¼ï¼Œæœ€ä½³ã€‚</p>
<pre tabindex="0"><code>$ curl --proto &#39;=https&#39; --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre><p>å®‰è£…æˆåŠŸåï¼Œå°†åœ¨å‘½ä»¤ç«¯è¾“å‡ºï¼š</p>
<pre tabindex="0"><code>Rust is installed now. Great!
</code></pre><h4 id="22-æ›´æ–°">2.2 æ›´æ–°</h4>
<pre tabindex="0"><code>$ rustup update
</code></pre><h4 id="23-åˆ é™¤">2.3 åˆ é™¤</h4>
<pre tabindex="0"><code>$ rustup self uninstall
</code></pre><p><strong>ä½¿ç”¨äº†è®¸å¤šè¯­è¨€åï¼Œè¿™ä¸ªæ˜¯å‘ç°æœ€è´´å¿ƒçš„ã€‚</strong></p>
<h4 id="24-ç‰ˆæœ¬æŸ¥çœ‹">2.4 ç‰ˆæœ¬æŸ¥çœ‹</h4>
<pre tabindex="0"><code>$ rustc --version
</code></pre><h4 id="25-é˜…è¯»æœ¬åœ°æ–‡æ¡£">2.5 é˜…è¯»æœ¬åœ°æ–‡æ¡£</h4>
<pre tabindex="0"><code>rustup doc
</code></pre><h3 id="3-helloworld">3. Hello,World!</h3>
<h4 id="31-åˆ›å»ºé¡¹ç›®è·¯å¾„">3.1 åˆ›å»ºé¡¹ç›®è·¯å¾„</h4>
<pre tabindex="0"><code>$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre><h4 id="32-ç¼–å†™å’Œè¿è¡Œrustç¨‹åº">3.2 ç¼–å†™å’Œè¿è¡ŒRustç¨‹åº</h4>
<p>åˆ›å»ºmain.rsæ–‡ä»¶ï¼Œç¼–å†™ä»¥ä¸‹ä»£ç ï¼š</p>
<pre tabindex="0"><code>fn main() {
    println!(&#34;Hello, world!&#34;);
}
</code></pre><p>ç¼–è¯‘å’Œè¿è¡Œä»£ç ï¼š</p>
<pre tabindex="0"><code>$ rustc main.rs
$ ./main
Hello, world!
</code></pre><p>rustc ç¼–è¯‘å•ä¸€çš„ç¨‹åºæ¯”è¾ƒå¥½ï¼Œä½†æ˜¯åˆ°çœŸæ­£çš„é¡¹ç›®ä¸­è¿˜æ˜¯æ¨èä½¿ç”¨Cargoå·¥å…·è¿›è¡Œç¼–è¯‘ã€‚</p>
<h3 id="4-hellocargo">4. Hello,Cargo!</h3>
<p>Cargoæ˜¯Rustç¼–è¯‘ç³»ç»Ÿå’ŒåŒ…ç®¡ç†å·¥å…·ã€‚</p>
<p>éªŒè¯cargoæ˜¯å¦å®‰è£…æˆåŠŸï¼š</p>
<pre tabindex="0"><code>cargo --version
</code></pre><h4 id="41-ä½¿ç”¨cargoåˆ›å»ºé¡¹ç›®">4.1 ä½¿ç”¨Cargoåˆ›å»ºé¡¹ç›®</h4>
<pre tabindex="0"><code>$ cargo new hello_cargo
$ cd hello_cargo
</code></pre><h4 id="42-ç¼–è¯‘å’Œè¿è¡Œcargoé¡¹ç›®">4.2 ç¼–è¯‘å’Œè¿è¡ŒCargoé¡¹ç›®</h4>
<p>ç¼–è¯‘ä»£ç ï¼š</p>
<pre tabindex="0"><code>$ cargo build
</code></pre><p>è·¯å¾„ä¸‹æ‰§è¡Œä»£ç ï¼š</p>
<pre tabindex="0"><code>$ ./target/debug/hello_cargo 
</code></pre><p>æ‰§è¡Œä»£ç ã€‚</p>
<pre tabindex="0"><code>$ cargo run
</code></pre><p>æ£€æŸ¥ä»£ç ï¼Œä½†æ˜¯ä¸äº§ç”Ÿå¯æ‰§è¡Œæ–‡ä»¶ã€‚</p>
<pre tabindex="0"><code>$ cargo check
</code></pre><h4 id="43-ç¼–è¯‘å‘å¸ƒç‰ˆæœ¬">4.3 ç¼–è¯‘å‘å¸ƒç‰ˆæœ¬</h4>
<pre tabindex="0"><code>$ cargo build --release
</code></pre><h3 id="5-çŒœè°œç¨‹åº">5. çŒœè°œç¨‹åº</h3>
<h4 id="51-åˆ›å»ºä¸€ä¸ªæ–°é¡¹ç›®">5.1 åˆ›å»ºä¸€ä¸ªæ–°é¡¹ç›®</h4>
<pre tabindex="0"><code>$ cargo new guessing_game
$ cd guessing_game
</code></pre><h4 id="52-å¤„ç†çŒœæµ‹">5.2 å¤„ç†çŒœæµ‹</h4>
<pre tabindex="0"><code>use std::io;

fn main() {
    println!(&#34;Guess the number!&#34;);

    println!(&#34;Please input your guess.&#34;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&#34;Failed to read line&#34;);

    println!(&#34;You guessed: {}&#34;, guess);
}
</code></pre><h4 id="53-æ•°å€¼å­˜å‚¨">5.3 æ•°å€¼å­˜å‚¨</h4>
<pre tabindex="0"><code>let mut guess = String::new();
</code></pre><h4 id="54-å¤„ç†å¼‚å¸¸">5.4 å¤„ç†å¼‚å¸¸</h4>
<pre tabindex="0"><code> .expect(&#34;Failed to read line&#34;);
</code></pre><h4 id="55-ä½¿ç”¨printlnå‡½æ•°æ‰“å°">5.5 ä½¿ç”¨println!å‡½æ•°æ‰“å°</h4>
<pre tabindex="0"><code> println!(&#34;You guessed: {}&#34;, guess);
</code></pre><h4 id="56-æ·»åŠ ä¾èµ–é¡¹">5.6 æ·»åŠ ä¾èµ–é¡¹</h4>
<p>åœ¨æ–‡ä»¶Cargo.tomlä¸­æ·»åŠ ï¼š</p>
<pre tabindex="0"><code>[dependencies]
rand = &#34;0.8.3&#34;
</code></pre><h4 id="57-æ›´æ–°é¡¹ç›®">5.7 æ›´æ–°é¡¹ç›®</h4>
<pre tabindex="0"><code>$ cargo build
</code></pre><h4 id="58-æ›´æ–°ä¾èµ–é¡¹ç‰ˆæœ¬">5.8 æ›´æ–°ä¾èµ–é¡¹ç‰ˆæœ¬</h4>
<pre tabindex="0"><code>$ cargo update
    Updating crates.io index
    Updating rand v0.8.3 -&gt; v0.8.4
</code></pre><p>æ­¤æ—¶randç‰ˆæœ¬æ›´æ–°æ”¯æœ€æ–°ã€‚</p>
<p>æˆ–è€…ç›´æ¥æ‰“å¼€ Cargo.tomlï¼Œä¿®æ”¹ç‰ˆæœ¬ã€‚</p>
<pre tabindex="0"><code>[dependencies]
rand = &#34;0.9.0&#34;
</code></pre><h4 id="59--åˆ›å»ºä¸€ä¸ªéšæœºæ•°">5.9  åˆ›å»ºä¸€ä¸ªéšæœºæ•°</h4>
<pre tabindex="0"><code>use std::io;
use rand::Rng;

fn main() {
    println!(&#34;Guess the number!&#34;);

    let secret_number = rand::thread_rng().gen_range(1..101);

    println!(&#34;The secret number is: {}&#34;, secret_number);

    println!(&#34;Please input your guess.&#34;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&#34;Failed to read line&#34;);

    println!(&#34;You guessed: {}&#34;, guess);
}
</code></pre><h4 id="510-æ¯”è¾ƒå¤§å°">5.10 æ¯”è¾ƒå¤§å°</h4>
<pre tabindex="0"><code>use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--

    println!(&#34;You guessed: {}&#34;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&#34;Too small!&#34;),
        Ordering::Greater =&gt; println!(&#34;Too big!&#34;),
        Ordering::Equal =&gt; println!(&#34;You win!&#34;),
    }
}
</code></pre><h4 id="511-æ·»åŠ å¾ªç¯">5.11 æ·»åŠ å¾ªç¯</h4>
<pre tabindex="0"><code>loop {
        println!(&#34;Please input your guess.&#34;);

        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&#34;Too small!&#34;),
            Ordering::Greater =&gt; println!(&#34;Too big!&#34;),
            Ordering::Equal =&gt; println!(&#34;You win!&#34;),
        }
    }
</code></pre><h4 id="512-è·³å‡ºå¾ªç¯">5.12 è·³å‡ºå¾ªç¯</h4>
<pre tabindex="0"><code>match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&#34;Too small!&#34;),
            Ordering::Greater =&gt; println!(&#34;Too big!&#34;),
            Ordering::Equal =&gt; {
                println!(&#34;You win!&#34;);
                break;
            }
        }
</code></pre><h4 id="513-å¤„ç†å¼‚å¸¸è¾“å…¥">5.13 å¤„ç†å¼‚å¸¸è¾“å…¥</h4>
<pre tabindex="0"><code>// --snip--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&#34;Failed to read line&#34;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&#34;You guessed: {}&#34;, guess);

// --snip--
</code></pre><h3 id="6-å¸¸è§ç¼–ç¨‹æ¦‚å¿µ">6. å¸¸è§ç¼–ç¨‹æ¦‚å¿µ</h3>
<h4 id="61-å˜é‡å’Œå¯å˜æ€§">6.1 å˜é‡å’Œå¯å˜æ€§</h4>
<pre tabindex="0"><code>let x = 6; //xä¸èƒ½è¢«èµ‹å€¼
let mut x =6; //xèƒ½è¢«èµ‹å€¼
</code></pre><h4 id="62-å˜é‡ä¸å¸¸é‡çš„å·®å¼‚">6.2 å˜é‡ä¸å¸¸é‡çš„å·®å¼‚</h4>
<pre tabindex="0"><code>const MAX_POINTS: u32 = 100_000;
</code></pre><h4 id="63-é˜´å½±æ•ˆæœ">6.3 é˜´å½±æ•ˆæœ</h4>
<pre tabindex="0"><code>let spaces = &#34;   &#34;;
let spaces = spaces.len();
</code></pre><p>let å†æ¬¡ä½¿ç”¨å…³é”®å­—æ—¶ï¼Œé‡æ–°åˆ›å»ºäº†ä¸€ä¸ªæ–°å˜é‡ã€‚</p>
<p>ä½†æ˜¯ä»¥ä¸‹çš„å®šä¹‰ä¸ºé”™è¯¯ï¼š</p>
<pre tabindex="0"><code> let mut spaces = &#34;   &#34;;
 spaces = spaces.len();
</code></pre><p>æ­¤æ—¶spaceså°†å˜æ”¹å˜ä¸ºæ•´å‹ï¼Œè€ŒéåŸæ¥çš„å­—ç¬¦å‹ã€‚</p>
<h4 id="64-æ•°æ®ç±»å‹">6.4 æ•°æ®ç±»å‹</h4>
<p>Rustæ˜¯é™æ€ç±»å‹è¯­è¨€ï¼Œç¼–è¯‘æ—¶éœ€è¦çŸ¥é“å˜é‡çš„ç±»å‹ã€‚</p>
<p>ä¾‹å¦‚ï¼š</p>
<pre tabindex="0"><code>let guess: u32 = &#34;42&#34;.parse().expect(&#34;Not a number!&#34;);
</code></pre><p>å¦‚æœæ²¡æœ‰ç±»å‹æ³¨é‡Šï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<pre tabindex="0"><code>let guess = &#34;42&#34;.parse().expect(&#34;Not a number!&#34;);
</code></pre><p>ç¼–è¯‘å°†å‡ºç°é”™è¯¯ã€‚</p>
<pre tabindex="0"><code>$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &#34;42&#34;.parse().expect(&#34;Not a number!&#34;);
  |         ^^^^^ consider giving `guess` a type

error: aborting due to previous error

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations`

To learn more, run the command again with --verbose.
</code></pre><h5 id="641-æ ‡é‡ç±»å‹">6.4.1 æ ‡é‡ç±»å‹</h5>
<p>Rust æœ‰å››ç§ä¸»è¦çš„æ ‡é‡ç±»å‹ï¼šæ•´æ•°ã€æµ®ç‚¹æ•°ã€å¸ƒå°”å€¼å’Œå­—ç¬¦ã€‚</p>
<ul>
<li>1.æ•´æ•°ç±»å‹</li>
</ul>
<table>
<thead>
<tr>
<th>Length</th>
<th>Signed</th>
<th>Unsigned</th>
</tr>
</thead>
<tbody>
<tr>
<td>8-bit</td>
<td>i8</td>
<td>u8</td>
</tr>
<tr>
<td>16-bit</td>
<td>i16</td>
<td>u16</td>
</tr>
<tr>
<td>32-bit</td>
<td>i32</td>
<td>u32</td>
</tr>
<tr>
<td>128-bit</td>
<td>i128</td>
<td>u128</td>
</tr>
<tr>
<td>arch</td>
<td>isize</td>
<td>usize</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Number literals</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Decimal</td>
<td>98_222</td>
</tr>
<tr>
<td>Hex</td>
<td>0xff</td>
</tr>
<tr>
<td>Octal</td>
<td>0o77</td>
</tr>
<tr>
<td>Binary</td>
<td>0b1111_0000</td>
</tr>
<tr>
<td>Byte</td>
<td>(u8 only)	b&rsquo;A'</td>
</tr>
</tbody>
</table>
<ul>
<li>2.æµ®ç‚¹ç±»å‹</li>
</ul>
<p>Rust ä¹Ÿæœ‰ä¸¤ç§ç”¨äºæµ®ç‚¹æ•°çš„åŸå§‹ç±»å‹ï¼Œå®ƒä»¬æ˜¯å¸¦å°æ•°ç‚¹çš„æ•°å­—ã€‚Rust çš„æµ®ç‚¹ç±»å‹æ˜¯f32and f64ï¼Œå®ƒä»¬çš„å¤§å°åˆ†åˆ«æ˜¯ 32 ä½å’Œ 64 ä½ã€‚é»˜è®¤ç±»å‹æ˜¯f64ã€‚ å› ä¸ºåœ¨ç°ä»£ CPU ä¸Šå®ƒçš„é€Ÿåº¦å¤§è‡´ç›¸åŒï¼Œf32ä½†ç²¾åº¦æ›´é«˜ã€‚</p>
<p>è¿™æ˜¯ä¸€ä¸ªæ˜¾ç¤ºæµ®ç‚¹æ•°çš„ç¤ºä¾‹ï¼š</p>
<pre tabindex="0"><code>fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre><p>æµ®ç‚¹æ•°æ ¹æ® IEEE-754 æ ‡å‡†è¡¨ç¤ºã€‚è¯¥ f32ç±»å‹æ˜¯å•ç²¾åº¦æµ®ç‚¹æ•°ï¼Œf64å…·æœ‰åŒç²¾åº¦ã€‚</p>
<ul>
<li>3.æ•°å€¼è¿ç®—</li>
</ul>
<pre tabindex="0"><code>fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;

    // remainder
    let remainder = 43 % 5;
}
</code></pre><ul>
<li>4.å¸ƒå°”ç±»å‹</li>
</ul>
<p>ä¸å¤§å¤šæ•°å…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸€æ ·ï¼ŒRust ä¸­çš„å¸ƒå°”ç±»å‹æœ‰ä¸¤ä¸ªå¯èƒ½çš„å€¼ï¼štrueå’Œfalseã€‚å¸ƒå°”å€¼å¤§å°ä¸º 1 ä¸ªå­—èŠ‚ã€‚Rust ä¸­çš„å¸ƒå°”ç±»å‹ä½¿ç”¨bool. ä¾‹å¦‚ï¼š</p>
<pre tabindex="0"><code>fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
</code></pre><ul>
<li>5.å­—ç¬¦ç±»å‹</li>
</ul>
<p>Rust çš„charç±»å‹å¤§å°ä¸ºå››ä¸ªå­—èŠ‚ï¼Œè¡¨ç¤ºä¸€ä¸ª Unicode æ ‡é‡å€¼ï¼Œè¿™æ„å‘³ç€å®ƒå¯ä»¥è¡¨ç¤ºçš„ä¸ä»…ä»…æ˜¯ ASCIIã€‚</p>
<pre tabindex="0"><code>fn main() {
    let c = &#39;z&#39;;
    let z = &#39;â„¤&#39;;
    let heart_eyed_cat = &#39;ğŸ˜»&#39;;
}
</code></pre><ul>
<li>6.å¤åˆç±»å‹</li>
</ul>
<p>å¤åˆç±»å‹å¯ä»¥å°†å¤šä¸ªå€¼åˆ†ç»„ä¸ºä¸€ç§ç±»å‹ã€‚Rust æœ‰ä¸¤ç§åŸå§‹çš„å¤åˆç±»å‹ï¼šå…ƒç»„å’Œæ•°ç»„ã€‚</p>
<p>1.å…ƒç»„ç±»å‹</p>
<p>å…ƒç»„æ˜¯å°†å…·æœ‰å¤šç§ç±»å‹çš„å¤šä¸ªå€¼ç»„åˆæˆä¸€ä¸ªå¤åˆç±»å‹çš„é€šç”¨æ–¹æ³•ã€‚å…ƒç»„æœ‰å›ºå®šçš„é•¿åº¦ï¼šä¸€æ—¦å£°æ˜ï¼Œå®ƒä»¬çš„å¤§å°å°±ä¸èƒ½å¢é•¿æˆ–ç¼©å°ã€‚</p>
<pre tabindex="0"><code>fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre><p>ä¹Ÿå¯ä»¥ä½¿ç”¨æ¨¡å¼åŒ¹é…æ¥è§£æ„å…ƒç»„å€¼ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<pre tabindex="0"><code>fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&#34;The value of y is: {}&#34;, y);
}
</code></pre><p>é™¤äº†é€šè¿‡æ¨¡å¼åŒ¹é…è¿›è¡Œè§£æ„ä¹‹å¤–ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥é€šè¿‡ä½¿ç”¨å¥ç‚¹ ( .) åè·Ÿæˆ‘ä»¬æƒ³è¦è®¿é—®çš„å€¼çš„ç´¢å¼•æ¥ç›´æ¥è®¿é—®å…ƒç»„å…ƒç´ ã€‚ä¾‹å¦‚ï¼š</p>
<pre tabindex="0"><code>fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre><p>è¯¥ç¨‹åºåˆ›å»ºä¸€ä¸ªå…ƒç»„ ï¼Œxç„¶åä½¿ç”¨å®ƒä»¬å„è‡ªçš„ç´¢å¼•ä¸ºæ¯ä¸ªå…ƒç´ åˆ›å»ºæ–°å˜é‡ã€‚ä¸å¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€ä¸€æ ·ï¼Œå…ƒç»„ä¸­çš„ç¬¬ä¸€ä¸ªç´¢å¼•æ˜¯ 0ã€‚</p>
<ul>
<li>7.æ•°ç»„ç±»å‹</li>
</ul>
<p>åœ¨ Rust ä¸­ï¼Œè¿›å…¥æ•°ç»„çš„å€¼è¢«å†™ä¸ºæ–¹æ‹¬å·å†…çš„é€—å·åˆ†éš”åˆ—è¡¨ï¼š</p>
<pre tabindex="0"><code>fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre><p>åœ¨éœ€è¦çŸ¥é“ä¸€å¹´ä¸­æœˆä»½åç§°çš„ç¨‹åºä¸­ï¼Œæ‚¨å¯èƒ½æƒ³è¦ä½¿ç”¨æ•°ç»„è€Œä¸æ˜¯å‘é‡çš„ç¤ºä¾‹ã€‚è¿™æ ·çš„ç¨‹åºä¸å¤ªå¯èƒ½éœ€è¦æ·»åŠ æˆ–åˆ é™¤æœˆä»½ï¼Œå› æ­¤æ‚¨å¯ä»¥ä½¿ç”¨æ•°ç»„ï¼Œå› ä¸ºæ‚¨çŸ¥é“å®ƒå§‹ç»ˆåŒ…å« 12 ä¸ªå…ƒç´ ï¼š</p>
<pre tabindex="0"><code>let months = [&#34;January&#34;, &#34;February&#34;, &#34;March&#34;, &#34;April&#34;, &#34;May&#34;, &#34;June&#34;, &#34;July&#34;,
              &#34;August&#34;, &#34;September&#34;, &#34;October&#34;, &#34;November&#34;, &#34;December&#34;];
</code></pre><p>æ‚¨å¯ä»¥ä½¿ç”¨æ–¹æ‹¬å·ç¼–å†™æ•°ç»„çš„ç±»å‹ï¼Œæ–¹æ‹¬å·å†…åŒ…å«æ¯ä¸ªå…ƒç´ çš„ç±»å‹ã€åˆ†å·ï¼Œç„¶åæ˜¯æ•°ç»„ä¸­çš„å…ƒç´ æ•°ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<pre tabindex="0"><code>let a: [i32; 5] = [1, 2, 3, 4, 5];
</code></pre><p>è¿™é‡Œï¼Œi32æ˜¯æ¯ä¸ªå…ƒç´ çš„ç±»å‹ã€‚åˆ†å·åçš„æ•°å­—5 è¡¨ç¤ºæ•°ç»„åŒ…å«äº”ä¸ªå…ƒç´ ã€‚</p>
<p>ä»¥è¿™ç§æ–¹å¼ç¼–å†™æ•°ç»„çš„ç±»å‹çœ‹èµ·æ¥ç±»ä¼¼äºåˆå§‹åŒ–æ•°ç»„çš„å¦ä¸€ç§è¯­æ³•ï¼šå¦‚æœæ‚¨æƒ³åˆ›å»ºä¸€ä¸ªæ•°ç»„ï¼Œå…¶ä¸­æ¯ä¸ªå…ƒç´ éƒ½åŒ…å«ç›¸åŒçš„å€¼ï¼Œæ‚¨å¯ä»¥æŒ‡å®šåˆå§‹å€¼ï¼Œåè·Ÿä¸€ä¸ªåˆ†å·ï¼Œç„¶åæ˜¯é•¿åº¦æ–¹æ‹¬å·ä¸­çš„æ•°ç»„ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<pre tabindex="0"><code>let a = [3; 5];
</code></pre><p>å‘½åçš„æ•°ç»„aå°†åŒ…å«5æ‰€æœ‰3æœ€åˆè®¾ç½®ä¸ºè¯¥å€¼çš„å…ƒç´  ã€‚è¿™ä¸å†™ä½œç›¸åŒï¼Œlet a = [3, 3, 3, 3, 3];ä½†æ–¹å¼æ›´ç®€æ´ã€‚</p>
<p>è®¿é—®æ•°ç»„å…ƒç´ ,å¯ä»¥ä½¿ç”¨ç´¢å¼•è®¿é—®æ•°ç»„çš„å…ƒç´ ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<pre tabindex="0"><code>fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre><p>åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œnamed çš„å˜é‡firstå°†è·å¾— value 1ï¼Œå› ä¸ºè¿™æ˜¯[0]æ•°ç»„ä¸­ç´¢å¼•å¤„çš„å€¼ã€‚å‘½åçš„å˜é‡secondå°†ä»æ•°ç»„ä¸­çš„2ç´¢å¼•[1]ä¸­è·å–å€¼ã€‚</p>
<h4 id="65-å‡½æ•°">6.5 å‡½æ•°</h4>
<p>å‡½æ•°åœ¨ Rust ä»£ç ä¸­æ— å¤„ä¸åœ¨ã€‚æ‚¨å·²ç»çœ‹åˆ°äº†è¯¥è¯­è¨€ä¸­æœ€é‡è¦çš„å‡½æ•°ä¹‹ä¸€ï¼šmainå‡½æ•°ï¼Œå®ƒæ˜¯è®¸å¤šç¨‹åºçš„å…¥å£ç‚¹ã€‚æ‚¨è¿˜çœ‹åˆ°äº†fnå…³é”®å­—ï¼Œå®ƒå…è®¸æ‚¨å£°æ˜æ–°å‡½æ•°ã€‚</p>
<p>Rust ä»£ç ä½¿ç”¨è›‡å½¢å¤§å°å†™ä½œä¸ºå‡½æ•°å’Œå˜é‡åç§°çš„å¸¸è§„æ ·å¼ã€‚åœ¨è›‡çš„æƒ…å†µä¸‹ï¼Œæ‰€æœ‰å­—æ¯éƒ½æ˜¯å°å†™çš„ï¼Œå¹¶ç”¨ä¸‹åˆ’çº¿åˆ†éš”å•è¯ã€‚è¿™æ˜¯ä¸€ä¸ªåŒ…å«ç¤ºä¾‹å‡½æ•°å®šä¹‰çš„ç¨‹åºï¼š</p>
<pre tabindex="0"><code>fn main() {
    println!(&#34;Hello, world!&#34;);

    another_function();
}

fn another_function() {
    println!(&#34;Another function.&#34;);
}
</code></pre><p>Rust ä¸­çš„å‡½æ•°å®šä¹‰ä»¥fnå‡½æ•°åå¼€å¤´ï¼Œå¹¶åœ¨å‡½æ•°ååæœ‰ä¸€ç»„æ‹¬å·ã€‚å¤§æ‹¬å·å‘Šè¯‰ç¼–è¯‘å™¨å‡½æ•°ä½“çš„å¼€å§‹å’Œç»“æŸä½ç½®ã€‚</p>
<p>Rust ä¸å…³å¿ƒä½ åœ¨å“ªé‡Œå®šä¹‰ä½ çš„å‡½æ•°ï¼Œåªå…³å¿ƒå®ƒä»¬æ˜¯åœ¨æŸå¤„å®šä¹‰çš„ã€‚</p>
<ul>
<li>1.åŠŸèƒ½å‚æ•°</li>
</ul>
<pre tabindex="0"><code>fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!(&#34;The value of x is: {}&#34;, x);
}
</code></pre><p>ä¸€ä¸ªå‡½æ•°æœ‰å¤šä¸ªå‚æ•°æ—¶ï¼Œç”¨é€—å·åˆ†éš”å‚æ•°å£°æ˜ï¼Œåƒè¿™æ ·ï¼š</p>
<pre tabindex="0"><code>fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!(&#34;The value of x is: {}&#34;, x);
    println!(&#34;The value of y is: {}&#34;, y);
}
</code></pre><p>åˆ›å»ºæ–°ä½œç”¨åŸŸçš„å—{}æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œä¾‹å¦‚ï¼š</p>
<pre tabindex="0"><code>n main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!(&#34;The value of y is: {}&#34;, y);
}
</code></pre><ul>
<li>2.å…·æœ‰è¿”å›å€¼çš„å‡½æ•°</li>
</ul>
<p>å‡½æ•°å¯ä»¥å°†å€¼è¿”å›ç»™è°ƒç”¨å®ƒä»¬çš„ä»£ç ã€‚æˆ‘ä»¬ä¸å‘½åè¿”å›å€¼ï¼Œä½†æˆ‘ä»¬ç¡®å®åœ¨ç®­å¤´ ( -&gt;)åå£°æ˜å®ƒä»¬çš„ç±»å‹ã€‚åœ¨ Rust ä¸­ï¼Œå‡½æ•°çš„è¿”å›å€¼ä¸å‡½æ•°ä½“å—ä¸­æœ€ç»ˆè¡¨è¾¾å¼çš„å€¼æ˜¯åŒä¹‰è¯ã€‚æ‚¨å¯ä»¥é€šè¿‡ä½¿ç”¨returnå…³é”®å­—å¹¶æŒ‡å®šå€¼ä»å‡½æ•°ä¸­æå‰è¿”å›ï¼Œä½†å¤§å¤šæ•°å‡½æ•°ä¼šéšå¼è¿”å›æœ€åä¸€ä¸ªè¡¨è¾¾å¼ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªè¿”å›å€¼çš„å‡½æ•°ç¤ºä¾‹ï¼š</p>
<pre tabindex="0"><code>fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&#34;The value of x is: {}&#34;, x);
}
</code></pre><h4 id="66-æ³¨é‡Š">6.6 æ³¨é‡Š</h4>
<p>åœ¨ Rust ä¸­ï¼Œæƒ¯ç”¨çš„æ³¨é‡Šæ ·å¼ä»¥ä¸¤ä¸ªæ–œæ å¼€å§‹æ³¨é‡Šï¼Œå¹¶ä¸”æ³¨é‡Šä¸€ç›´æŒç»­åˆ°è¡Œå°¾ã€‚å¯¹äºè¶…å‡ºå•è¡Œçš„æ³¨é‡Šï¼Œæ‚¨éœ€è¦//åœ¨æ¯ä¸€è¡Œä¸­åŒ…å«ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<pre tabindex="0"><code>// So weâ€™re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain whatâ€™s going on.
</code></pre><p>æ³¨é‡Šä¹Ÿå¯ä»¥æ”¾åœ¨åŒ…å«ä»£ç çš„è¡Œçš„æœ«å°¾ï¼š</p>
<pre tabindex="0"><code>fn main() {
    let lucky_number = 7; // Iâ€™m feeling lucky today
}
</code></pre><p>ä½†æ˜¯ä½ ä¼šæ›´ç»å¸¸åœ°çœ‹åˆ°å®ƒä»¬ä»¥è¿™ç§æ ¼å¼ä½¿ç”¨ï¼Œæ³¨é‡Šåœ¨å®ƒæ‰€æ³¨é‡Šçš„ä»£ç ä¸Šæ–¹çš„å•ç‹¬è¡Œä¸Šï¼š</p>
<pre tabindex="0"><code>fn main() {
    // Iâ€™m feeling lucky today
    let lucky_number = 7;
}
</code></pre><p>Rust è¿˜æœ‰å¦ä¸€ç§æ³¨é‡Šï¼Œæ–‡æ¡£æ³¨é‡Šï¼Œæˆ‘ä»¬å°†åœ¨ç¬¬ 14 ç« çš„â€œå°† Crate å‘å¸ƒåˆ° Crates.ioâ€ä¸€èŠ‚ä¸­è®¨è®ºã€‚</p>
<h4 id="67æ§åˆ¶æµ">6.7æ§åˆ¶æµ</h4>
<ul>
<li>1.ifè¡¨è¾¾å¼</li>
</ul>
<pre tabindex="0"><code>fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&#34;condition was true&#34;);
    } else {
        println!(&#34;condition was false&#34;);
    }
}
</code></pre><p>å¿…é¡»æ˜ç¡®å¹¶å§‹ç»ˆæä¾› ifå¸ƒå°”å€¼ä½œä¸ºå…¶æ¡ä»¶ã€‚</p>
<pre tabindex="0"><code>fn main() {
    let number = 3;

    if number != 0 {
        println!(&#34;number was something other than zero&#34;);
    }
}
</code></pre><ul>
<li>2.å¤„ç†å¤šä¸ªæ¡ä»¶ else if</li>
</ul>
<pre tabindex="0"><code>fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&#34;number is divisible by 4&#34;);
    } else if number % 3 == 0 {
        println!(&#34;number is divisible by 3&#34;);
    } else if number % 2 == 0 {
        println!(&#34;number is divisible by 2&#34;);
    } else {
        println!(&#34;number is not divisible by 4, 3, or 2&#34;);
    }
}
</code></pre><ul>
<li>3.ä½¿ç”¨ifçš„letè¯­å¥</li>
</ul>
<pre tabindex="0"><code>fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!(&#34;The value of number is: {}&#34;, number);
}
</code></pre><ul>
<li>4.å¾ªç¯é‡å¤</li>
</ul>
<p>Rustæœ‰ä¸‰ç§å¾ªç¯ï¼šloopï¼Œwhileï¼Œå’Œforã€‚</p>
<p>ï¼ˆ1ï¼‰é‡å¤ä»£ç  loop</p>
<p>è¯¥loopå…³é”®å­—å‘Šè¯‰Rustæ°¸è¿œæ¯”æ‰§è¡Œçš„ä»£ç å—ä¸€éåˆä¸€éï¼Œæˆ–è€…ç›´åˆ°ä½ æ˜ç¡®å‘Šè¯‰å®ƒåœæ­¢ã€‚</p>
<pre tabindex="0"><code>fn main() {
    loop {
        println!(&#34;again!&#34;);
    }
}
</code></pre><p>ä»å¾ªç¯è¿”å›å€¼</p>
<pre tabindex="0"><code>fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!(&#34;The result is {}&#34;, result);
}
</code></pre><p>(2)æ¡ä»¶å¾ªç¯ while</p>
<pre tabindex="0"><code>fn main() {
    let mut number = 3;

    while number != 0 {
        println!(&#34;{}!&#34;, number);

        number -= 1;
    }

    println!(&#34;LIFTOFF!!!&#34;);
}
</code></pre><p>(3)å¾ªç¯éå†é›†åˆ for</p>
<p>whileæ–¹å¼ï¼š</p>
<pre tabindex="0"><code>fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&#34;the value is: {}&#34;, a[index]);

        index += 1;
    }
}
</code></pre><p>for æ–¹å¼ï¼š</p>
<pre tabindex="0"><code>fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!(&#34;the value is: {}&#34;, element);
    }
}
</code></pre><h3 id="7-æ‰€æœ‰æƒ">7. æ‰€æœ‰æƒ</h3>
<p>æ‰€æœ‰æƒæ˜¯ Rust æœ€ç‹¬ç‰¹çš„ç‰¹æ€§ï¼Œå®ƒä½¿ Rust èƒ½å¤Ÿåœ¨ä¸éœ€è¦åƒåœ¾æ”¶é›†å™¨çš„æƒ…å†µä¸‹åšå‡ºå†…å­˜å®‰å…¨ä¿è¯ã€‚å› æ­¤ï¼Œäº†è§£æ‰€æœ‰æƒåœ¨ Rust ä¸­çš„è¿ä½œæ–¹å¼éå¸¸é‡è¦ã€‚åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†è®¨è®ºæ‰€æœ‰æƒä»¥åŠå‡ ä¸ªç›¸å…³çš„ç‰¹æ€§ï¼šå€Ÿç”¨ã€åˆ‡ç‰‡ï¼Œä»¥åŠ Rust å¦‚ä½•åœ¨å†…å­˜ä¸­å¸ƒç½®æ•°æ®ã€‚</p>
<h4 id="1æ‰€æœ‰æƒè§„åˆ™">1.æ‰€æœ‰æƒè§„åˆ™</h4>
<ul>
<li>Rust ä¸­çš„æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªå˜é‡ï¼Œç§°ä¸ºå…¶ownerã€‚</li>
<li>ä¸€æ¬¡åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ã€‚</li>
<li>å½“æ‰€æœ‰è€…è¶…å‡ºèŒƒå›´æ—¶ï¼Œè¯¥å€¼å°†è¢«åˆ é™¤ã€‚</li>
</ul>
<p><strong>è¯»ä¸æ‡‚äº†ï¼Ÿï¼Ÿï¼Ÿ</strong></p>
<h3 id="8ç»“æ„">8.ç»“æ„</h3>
<h4 id="81-å®šä¹‰å’Œå®ä¾‹åŒ–ç»“æ„">8.1 å®šä¹‰å’Œå®ä¾‹åŒ–ç»“æ„</h4>
<pre tabindex="0"><code>struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
</code></pre><pre tabindex="0"><code>let user1 = User {
        email: String::from(&#34;someone@example.com&#34;),
        username: String::from(&#34;someusername123&#34;),
        active: true,
        sign_in_count: 1,
    };
</code></pre><h4 id="82-ç»“æ„æ–¹æ³•è¯­æ³•">8.2 ç»“æ„æ–¹æ³•è¯­æ³•</h4>
<pre tabindex="0"><code>#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &#34;The area of the rectangle is {} square pixels.&#34;,
        rect1.area()
    );
}
</code></pre><h3 id="9æšä¸¾å’Œæ¨¡å¼åŒ¹é…">9.æšä¸¾å’Œæ¨¡å¼åŒ¹é…</h3>
<h4 id="91-å®šä¹‰æšä¸¾">9.1 å®šä¹‰æšä¸¾</h4>
<pre tabindex="0"><code>enum IpAddrKind {
    V4,
    V6,
}
</code></pre><h4 id="92-æšä¸¾å€¼">9.2 æšä¸¾å€¼</h4>
<pre tabindex="0"><code>let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
</code></pre><p>ç»“åˆç»“æ„å’Œæšä¸¾çš„ä½¿ç”¨ï¼š</p>
<pre tabindex="0"><code> enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from(&#34;127.0.0.1&#34;),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from(&#34;::1&#34;),
    };
</code></pre><h4 id="93-åŒ¹é…æ§åˆ¶æµç¨‹æ“ä½œç¬¦">9.3 åŒ¹é…æ§åˆ¶æµç¨‹æ“ä½œç¬¦</h4>
<pre tabindex="0"><code>enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
</code></pre><h4 id="94-_å ä½ç¬¦">9.4 &ldquo;_&ldquo;å ä½ç¬¦</h4>
<p>è¯¥_æ¨¡å¼å°†åŒ¹é…ä»»ä½•å€¼ã€‚</p>
<pre tabindex="0"><code> let some_u8_value = 0u8;
    match some_u8_value {
        1 =&gt; println!(&#34;one&#34;),
        3 =&gt; println!(&#34;three&#34;),
        5 =&gt; println!(&#34;five&#34;),
        7 =&gt; println!(&#34;seven&#34;),
        _ =&gt; (),
    }
</code></pre><h4 id="95-if-let">9.5 if let</h4>
<pre tabindex="0"><code> let some_u8_value = Some(0u8);
   match some_u8_value {
       Some(3) =&gt; println!(&#34;three&#34;),
       _ =&gt; (),
   }
</code></pre><h3 id="10ç®¡ç†ä¸æ–­å¢é•¿çš„é¡¹ç›®">10.ç®¡ç†ä¸æ–­å¢é•¿çš„é¡¹ç›®</h3>
<ul>
<li>
<p>Packages: A Cargo feature that lets you build, test, and share crates</p>
</li>
<li>
<p>Crates: A tree of modules that produces a library or executable</p>
</li>
<li>
<p>Modules and use: Let you control the organization, scope, and privacy of paths</p>
</li>
<li>
<p>Paths: A way of naming an item, such as a struct, function, or module</p>
</li>
</ul>
<h4 id="101-packages-and-crates">10.1 Packages and Crates</h4>
<pre tabindex="0"><code> cargo new my-project
    Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre><h4 id="102-å®šä¹‰æ¨¡å—ä»¥æ§åˆ¶èŒƒå›´å’Œéšç§">10.2 å®šä¹‰æ¨¡å—ä»¥æ§åˆ¶èŒƒå›´å’Œéšç§</h4>
<p>æ–‡ä»¶åï¼šsrc/lib.rs</p>
<pre tabindex="0"><code>mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
</code></pre><p>æ¨¡å—æ ‘ï¼š</p>
<pre tabindex="0"><code>crate
 â””â”€â”€ front_of_house
     â”œâ”€â”€ hosting
     â”‚   â”œâ”€â”€ add_to_waitlist
     â”‚   â””â”€â”€ seat_at_table
     â””â”€â”€ serving
         â”œâ”€â”€ take_order
         â”œâ”€â”€ serve_order
         â””â”€â”€ take_payment
</code></pre><h4 id="103-å¼•ç”¨æ¨¡å—æ ‘ä¸­é¡¹ç›®çš„è·¯å¾„">10.3 å¼•ç”¨æ¨¡å—æ ‘ä¸­é¡¹ç›®çš„è·¯å¾„</h4>
<pre tabindex="0"><code>mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre><h4 id="104-ä½¿ç”¨useå…³é”®å­—å°†è·¯å¾„çº³å…¥èŒƒå›´">10.4 ä½¿ç”¨useå…³é”®å­—å°†è·¯å¾„çº³å…¥èŒƒå›´</h4>
<pre tabindex="0"><code>mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
</code></pre><h4 id="105-å°†æ¨¡å—åˆ†æˆä¸åŒçš„æ–‡ä»¶">10.5 å°†æ¨¡å—åˆ†æˆä¸åŒçš„æ–‡ä»¶</h4>
<pre tabindex="0"><code>mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
</code></pre><h3 id="11-å¸¸è§é›†åˆ">11 å¸¸è§é›†åˆ</h3>
<p>Rust çš„æ ‡å‡†åº“åŒ…æ‹¬è®¸å¤šéå¸¸æœ‰ç”¨çš„æ•°æ®ç»“æ„ï¼Œç§°ä¸ºé›†åˆã€‚</p>
<h4 id="111-ç”¨å‘é‡å­˜å‚¨å€¼åˆ—è¡¨">11.1 ç”¨å‘é‡å­˜å‚¨å€¼åˆ—è¡¨</h4>
<p>æˆ‘ä»¬å°†çœ‹åˆ°çš„ç¬¬ä¸€ä¸ªé›†åˆç±»å‹æ˜¯Vec<!-- raw HTML omitted -->ï¼Œä¹Ÿç§°ä¸ºå‘é‡ã€‚å‘é‡å…è®¸æ‚¨åœ¨å•ä¸ªæ•°æ®ç»“æ„ä¸­å­˜å‚¨å¤šä¸ªå€¼ï¼Œè¯¥æ•°æ®ç»“æ„å°†æ‰€æœ‰å€¼å¹¶æ’æ”¾ç½®åœ¨å†…å­˜ä¸­ã€‚å‘é‡åªèƒ½å­˜å‚¨ç›¸åŒç±»å‹çš„å€¼ã€‚å½“æ‚¨æœ‰ä¸€ä¸ªé¡¹ç›®åˆ—è¡¨æ—¶ï¼Œå®ƒä»¬å¾ˆæœ‰ç”¨ï¼Œä¾‹å¦‚æ–‡ä»¶ä¸­çš„æ–‡æœ¬è¡Œæˆ–è´­ç‰©è½¦ä¸­é¡¹ç›®çš„ä»·æ ¼ã€‚</p>
<ul>
<li>1.åˆ›å»ºæ–°å‘é‡</li>
</ul>
<pre tabindex="0"><code> let v: Vec&lt;i32&gt; = Vec::new();
</code></pre><ul>
<li>2.æ›´æ–°å‘é‡</li>
</ul>
<pre tabindex="0"><code>let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
</code></pre><h4 id="112-å­˜å‚¨utf-8å­—ç¬¦ä¸²">11.2 å­˜å‚¨UTF-8å­—ç¬¦ä¸²</h4>
<pre tabindex="0"><code>    let hello = String::from(&#34;Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…&#34;);
    let hello = String::from(&#34;DobrÃ½ den&#34;);
    let hello = String::from(&#34;Hello&#34;);
    let hello = String::from(&#34;×©Ö¸××œ×•Ö¹×&#34;);
    let hello = String::from(&#34;à¤¨à¤®à¤¸à¥à¤¤à¥‡&#34;);
    let hello = String::from(&#34;ã“ã‚“ã«ã¡ã¯&#34;);
    let hello = String::from(&#34;ì•ˆë…•í•˜ì„¸ìš”&#34;);
    let hello = String::from(&#34;ä½ å¥½&#34;);
    let hello = String::from(&#34;OlÃ¡&#34;);
    let hello = String::from(&#34;Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ&#34;);
    let hello = String::from(&#34;Hola&#34;);
</code></pre><ul>
<li>1.æ·»åŠ å­—ç¬¦ä¸²</li>
</ul>
<pre tabindex="0"><code>let mut s = String::from(&#34;lo&#34;);
s.push(&#39;l&#39;);
</code></pre><p>ä½¿ç”¨æ“ä½œç¬¦ &ldquo;+&ldquo;è¿›è¡Œå­—ç¬¦ä¸²æ“ä½œï¼š</p>
<pre tabindex="0"><code>    let s1 = String::from(&#34;Hello, &#34;);
    let s2 = String::from(&#34;world!&#34;);
    let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used
</code></pre><h4 id="113-hashmap">11.3 HashMap</h4>
<pre tabindex="0"><code>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&#34;Blue&#34;), 10);
scores.insert(String::from(&#34;Yellow&#34;), 50);

//Accessing Values in a Hash Map
let team_name = String::from(&#34;Blue&#34;);
let score = scores.get(&amp;team_name);

for (key, value) in &amp;scores {
        println!(&#34;{}: {}&#34;, key, value);
    }

//Overwriting a Value
scores.insert(String::from(&#34;Blue&#34;), 25);
</code></pre><h3 id="12-é”™è¯¯å¤„ç†">12 é”™è¯¯å¤„ç†</h3>
<h4 id="121-panic">12.1 panic</h4>
<pre tabindex="0"><code>fn main() {
    panic!(&#34;crash and burn&#34;);
}
</code></pre><pre tabindex="0"><code>RUST_BACKTRACE=1 cargo run
</code></pre><p>æ‰“å°é”™è¯¯è¯¦ç»†ä¿¡æ¯ã€‚</p>
<h4 id="122-å¸¦é”™è¯¯ä¿¡æ¯çš„é”™è¯¯å¤„ç†">12.2 å¸¦é”™è¯¯ä¿¡æ¯çš„é”™è¯¯å¤„ç†</h4>
<pre tabindex="0"><code>use std::fs::File;

fn main() {
    let f = File::open(&#34;hello.txt&#34;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!(&#34;Problem opening the file: {:?}&#34;, error),
    };
}
</code></pre><p>å¤šé”™è¯¯å¤„ç†ï¼š</p>
<pre tabindex="0"><code>use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&#34;hello.txt&#34;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&#34;hello.txt&#34;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&#34;Problem creating the file: {:?}&#34;, e),
            },
            other_error =&gt; {
                panic!(&#34;Problem opening the file: {:?}&#34;, other_error)
            }
        },
    };
}
</code></pre><h4 id="123-ä½•æ—¶ä½¿ç”¨panic">12.3 ä½•æ—¶ä½¿ç”¨panic</h4>
<pre tabindex="0"><code>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&#34;Guess value must be between 1 and 100, got {}.&#34;, value);
        }

        Guess { value }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
</code></pre><h3 id="13æ³›å‹ç±»å‹ç‰¹æ€§å’Œç”Ÿå‘½å‘¨æœŸ">13.æ³›å‹ç±»å‹ã€ç‰¹æ€§å’Œç”Ÿå‘½å‘¨æœŸ</h3>
<p>æå–å‡½æ•°ï¼Œå»é‡å¤</p>
<pre tabindex="0"><code>fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&#34;The largest number is {}&#34;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&#34;The largest number is {}&#34;, largest);
}
</code></pre><p>æå–åï¼Œå°†è½¬å˜ä¸ºä»¥ä¸‹å‡½æ•°ï¼š</p>
<pre tabindex="0"><code>fn largest(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&#34;The largest number is {}&#34;, result);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&#34;The largest number is {}&#34;, result);
}
</code></pre><h4 id="131-é€šç”¨æ•°æ®ç±»å‹">13.1 é€šç”¨æ•°æ®ç±»å‹</h4>
<ul>
<li>1.å‡½æ•°å®šä¹‰</li>
</ul>
<pre tabindex="0"><code>fn largest_i32(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; char {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&#34;The largest number is {}&#34;, result);

    let char_list = vec![&#39;y&#39;, &#39;m&#39;, &#39;a&#39;, &#39;q&#39;];

    let result = largest_char(&amp;char_list);
    println!(&#34;The largest char is {}&#34;, result);
}
</code></pre><p>å°†æ•°å­—æ¯”è¾ƒå’Œå­—ç¬¦æ¯”è¾ƒï¼Œéƒ½ä½¿ç”¨æ³›å‹çš„æ–¹å¼ï¼š</p>
<pre tabindex="0"><code>fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&#34;The largest number is {}&#34;, result);

    let char_list = vec![&#39;y&#39;, &#39;m&#39;, &#39;a&#39;, &#39;q&#39;];

    let result = largest(&amp;char_list);
    println!(&#34;The largest char is {}&#34;, result);
}
</code></pre><ul>
<li>2.ç»“æ„å®šä¹‰</li>
</ul>
<pre tabindex="0"><code>struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre><ul>
<li>2.æšä¸¾å®šä¹‰</li>
</ul>
<pre tabindex="0"><code>enum Option&lt;T&gt; {
    Some(T),
    None,
}
</code></pre><p>æˆ–è€…</p>
<pre tabindex="0"><code>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre><ul>
<li>3.æ–¹æ³•å®šä¹‰</li>
</ul>
<pre tabindex="0"><code>struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&#34;p.x = {}&#34;, p.x());
}
</code></pre><p>ä¸€ä¸ªæ›´åŠ å¤æ‚çš„ä¾‹å­ï¼š</p>
<pre tabindex="0"><code>struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &#34;Hello&#34;, y: &#39;c&#39; };

    let p3 = p1.mixup(p2);

    println!(&#34;p3.x = {}, p3.y = {}&#34;, p3.x, p3.y);
}
</code></pre><ul>
<li>
<ol start="3">
<li>ä»£ç å®šä¹‰</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>let integer = Some(5);
let float = Some(5.0);
</code></pre><h4 id="132-ç‰¹æ€§å®šä¹‰å…±äº«è¡Œä¸º">13.2 ç‰¹æ€§ï¼šå®šä¹‰å…±äº«è¡Œä¸º</h4>
<p>å®šä¹‰ç‰¹æ€§ï¼š</p>
<pre tabindex="0"><code>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
</code></pre><p>åœ¨ç»“æ„ä¸­åˆ†åˆ«å®ç°ï¼š</p>
<pre tabindex="0"><code>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&#34;{}, by {} ({})&#34;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&#34;{}: {}&#34;, self.username, self.content)
    }
}
</code></pre><p>å‡½æ•°ä¸­ä½¿ç”¨ç‰¹æ€§ï¼š</p>
<pre tabindex="0"><code>fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&#34;The largest number is {}&#34;, result);

    let char_list = vec![&#39;y&#39;, &#39;m&#39;, &#39;a&#39;, &#39;q&#39;];

    let result = largest(&amp;char_list);
    println!(&#34;The largest char is {}&#34;, result);
}
</code></pre><h4 id="133-å¼•ç”¨ç”Ÿå‘½å‘¨æœŸ">13.3 å¼•ç”¨ç”Ÿå‘½å‘¨æœŸ</h4>
<ul>
<li>1.å‡½æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸ</li>
</ul>
<pre tabindex="0"><code>fn main() {
    let string1 = String::from(&#34;abcd&#34;);
    let string2 = &#34;xyz&#34;;

    let result = longest(string1.as_str(), string2);
    println!(&#34;The longest string is {}&#34;, result);
}
</code></pre><ul>
<li>2.ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šè¯­æ³•</li>
</ul>
<pre tabindex="0"><code>&amp;i32        // a reference
&amp;&#39;a i32     // a reference with an explicit lifetime
&amp;&#39;a mut i32 // a mutable reference with an explicit lifetime
</code></pre><ul>
<li>3.å‡½æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸæ³¨é‡Š</li>
</ul>
<pre tabindex="0"><code>fn longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;str) -&gt; &amp;&#39;a str {
    x
}
</code></pre><ul>
<li>4.é™æ€ç”Ÿå‘½å‘¨æœŸ</li>
</ul>
<pre tabindex="0"><code>let s: &amp;&#39;static str = &#34;I have a static lifetime.&#34;;
</code></pre><ul>
<li>5.é€šç”¨ç±»å‹å‚æ•°ã€ç‰¹å¾è¾¹ç•Œå’Œç”Ÿå‘½å‘¨æœŸ</li>
</ul>
<pre tabindex="0"><code>use std::fmt::Display;

fn longest_with_an_announcement&lt;&#39;a, T&gt;(
    x: &amp;&#39;a str,
    y: &amp;&#39;a str,
    ann: T,
) -&gt; &amp;&#39;a str
where
    T: Display,
{
    println!(&#34;Announcement! {}&#34;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre><h3 id="14-ç¼–å†™è‡ªåŠ¨åŒ–æµ‹è¯•">14. ç¼–å†™è‡ªåŠ¨åŒ–æµ‹è¯•</h3>
<pre tabindex="0"><code>cargo test --help
</code></pre><h4 id="141-å¦‚ä½•ç¼–å†™æµ‹è¯•">14.1 å¦‚ä½•ç¼–å†™æµ‹è¯•</h4>
<ul>
<li>1.ç¼–å†™è‡ªåŠ¨åŒ–æµ‹è¯•</li>
</ul>
<pre tabindex="0"><code>#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!(&#34;Make this test fail&#34;);
    }
}
</code></pre><h4 id="142">14.2</h4>
<p>å¹¶è¡Œæµ‹è¯•</p>
<pre tabindex="0"><code>$ cargo test -- --test-threads=1
</code></pre><p>æ˜¾ç¤ºè¾“å‡ºä¿¡æ¯ï¼š</p>
<pre tabindex="0"><code>cargo test -- --show-output
</code></pre><p>æµ‹è¯•å‡½æ•°ï¼š</p>
<pre tabindex="0"><code>pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
</code></pre><pre tabindex="0"><code>cargo test one_hundred
</code></pre><p>åŒ¹é…å‡½æ•°åç§°è¿›è¡Œæµ‹è¯•ï¼Œæ‰€æœ‰çš„addå¼€å¤´éƒ½ä¼šè¢«æµ‹è¯•ï¼š</p>
<pre tabindex="0"><code>cargo test add
</code></pre><p>å¿½ç•¥æµ‹è¯•æ ‡è®°ï¼š</p>
<pre tabindex="0"><code>#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}
</code></pre><pre tabindex="0"><code>cargo test -- --ignored
</code></pre><h4 id="143-æµ‹è¯•ç»“æ„">14.3 æµ‹è¯•ç»“æ„</h4>
<ul>
<li>1.å•å…ƒæµ‹è¯•</li>
</ul>
<pre tabindex="0"><code>#[cfg(test)]
</code></pre><pre tabindex="0"><code>#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre><ul>
<li>2.ç§æœ‰å‡½æ•°æµ‹è¯•</li>
</ul>
<pre tabindex="0"><code>pub fn add_two(a: i32) -&gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
</code></pre><h3 id="15-ä¸€ä¸ªè¯»å†™é¡¹ç›®æ„å»ºä¸€ä¸ªå‘½ä»¤è¡Œç¨‹åº">15. ä¸€ä¸ªè¯»å†™é¡¹ç›®ï¼šæ„å»ºä¸€ä¸ªå‘½ä»¤è¡Œç¨‹åº</h3>
<h4 id="151-æ¥æ”¶å‘½ä»¤è¡Œå‚æ•°">15.1 æ¥æ”¶å‘½ä»¤è¡Œå‚æ•°</h4>
<ul>
<li>1.è¯»å–å‚æ•°</li>
</ul>
<pre tabindex="0"><code>use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!(&#34;{:?}&#34;, args);
}
</code></pre><ul>
<li>2.å­˜å‚¨å‚æ•°</li>
</ul>
<pre tabindex="0"><code>use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let filename = &amp;args[2];

    println!(&#34;Searching for {}&#34;, query);
    println!(&#34;In file {}&#34;, filename);
}
</code></pre><h4 id="152-è¯»å–æ–‡ä»¶">15.2 è¯»å–æ–‡ä»¶</h4>
<pre tabindex="0"><code>use std::env;
use std::fs;
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let filename = &amp;args[2];

    println!(&#34;Searching for {}&#34;, query);
    println!(&#34;In file {}&#34;, filename);

    let contents = fs::read_to_string(filename)
        .expect(&#34;Something went wrong reading the file&#34;);

    println!(&#34;With text:\n{}&#34;, contents);
}
</code></pre><h4 id="153-æé«˜æ¨¡å—åŒ–å’Œé”™è¯¯å¤„ç†">15.3 æé«˜æ¨¡å—åŒ–å’Œé”™è¯¯å¤„ç†</h4>
<p>lib.rs</p>
<pre tabindex="0"><code>use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; {
        if args.len() &lt; 3 {
            panic!(&#34;not enough arguments&#34;);
        }
        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.filename)?;

    println!(&#34;With text:\n{}&#34;, contents);

    Ok(())
}
</code></pre><p>main.rs</p>
<pre tabindex="0"><code>use std::env;

use std::process;
use minigrep::Config;


fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&#34;Problem parsing arguments: {}&#34;, err);
        process::exit(1);
    });

    println!(&#34;Searching for {}&#34;, config.query);
    println!(&#34;In file {}&#34;, config.filename);

    if let Err(e) = minigrep::run(config) {
        println!(&#34;Application error: {}&#34;, e);

        process::exit(1);
    }
}
</code></pre><h4 id="154-ä½¿ç”¨æµ‹è¯•é©±åŠ¨å¼€å‘å¼€å‘åº“çš„åŠŸèƒ½">15.4 ä½¿ç”¨æµ‹è¯•é©±åŠ¨å¼€å‘å¼€å‘åº“çš„åŠŸèƒ½</h4>
<pre tabindex="0"><code>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = &#34;duct&#34;;
        let contents = &#34;\
Rust:
safe, fast, productive.
Pick three.&#34;;

        assert_eq!(vec![&#34;safe, fast, productive.&#34;], search(query, contents));
    }
}
</code></pre><h4 id="155-ä½¿ç”¨ç¯å¢ƒå˜é‡">15.5 ä½¿ç”¨ç¯å¢ƒå˜é‡</h4>
<pre tabindex="0"><code>CASE_INSENSITIVE=1 cargo run to poem.txt
</code></pre><h4 id="156-å°†é”™è¯¯å†™å‡ºåˆ°æ ‡å‡†è¾“å‡º">15.6 å°†é”™è¯¯å†™å‡ºåˆ°æ ‡å‡†è¾“å‡º</h4>
<pre tabindex="0"><code>cargo run &gt; output.txt
</code></pre><p>ä½¿ç”¨<strong>eprintln!()</strong> ä»£æ›¿ <strong>println!()</strong>ã€‚</p>
<h3 id="16-å‡½æ•°å¼è¯­è¨€ç‰¹æ€§è¿­ä»£å™¨å’Œé—­åŒ…">16. å‡½æ•°å¼è¯­è¨€ç‰¹æ€§ï¼šè¿­ä»£å™¨å’Œé—­åŒ…</h3>
<h4 id="161-åˆ›å»ºé—­åŒ…æŠ½è±¡è¡Œä¸º">16.1 åˆ›å»ºé—­åŒ…æŠ½è±¡è¡Œä¸º</h4>
<pre tabindex="0"><code>use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
    println!(&#34;calculating slowly...&#34;);
    thread::sleep(Duration::from_secs(2));
    intensity
}
</code></pre><h4 id="162-ä½¿ç”¨è¿­ä»£å™¨å¤„ç†ä¸€ç³»åˆ—é¡¹ç›®">16.2 ä½¿ç”¨è¿­ä»£å™¨å¤„ç†ä¸€ç³»åˆ—é¡¹ç›®</h4>
<pre tabindex="0"><code>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!(&#34;Got: {}&#34;, val);
    }
</code></pre><h4 id="163-æ”¹è¿›ioé¡¹ç›®">16.3 æ”¹è¿›I/Oé¡¹ç›®</h4>
<pre tabindex="0"><code>impl Config {
    pub fn new(mut args: env::Args) -&gt; Result&lt;Config, &amp;&#39;static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&#34;Didn&#39;t get a query string&#34;),
        };

        let filename = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&#34;Didn&#39;t get a file name&#34;),
        };

        let case_sensitive = env::var(&#34;CASE_INSENSITIVE&#34;).is_err();

        Ok(Config {
            query,
            filename,
            case_sensitive,
        })
    }
}
</code></pre><pre tabindex="0"><code>pub fn search&lt;&#39;a&gt;(query: &amp;str, contents: &amp;&#39;a str) -&gt; Vec&lt;&amp;&#39;a str&gt; {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
</code></pre><h4 id="164-æ¯”è¾ƒæ€§èƒ½å¾ªç¯ä¸è¿­ä»£å™¨">16.4 æ¯”è¾ƒæ€§èƒ½ï¼šå¾ªç¯ä¸è¿­ä»£å™¨</h4>
<p>é—­åŒ…å’Œè¿­ä»£å™¨æ˜¯å—å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€æ€æƒ³å¯å‘çš„ Rust ç‰¹æ€§ã€‚å®ƒä»¬æœ‰åŠ©äº Rust ä»¥ä½çº§æ€§èƒ½æ¸…æ™°è¡¨è¾¾é«˜çº§æ€æƒ³çš„èƒ½åŠ›ã€‚é—­åŒ…å’Œè¿­ä»£å™¨çš„å®ç°ä¸ä¼šå½±å“è¿è¡Œæ—¶æ€§èƒ½ã€‚è¿™æ˜¯ Rust åŠªåŠ›æä¾›é›¶æˆæœ¬æŠ½è±¡ç›®æ ‡çš„ä¸€éƒ¨åˆ†ã€‚</p>
<h3 id="17-æ›´å¤šçš„å…³äºcargoå’Œcratesio">17. æ›´å¤šçš„å…³äºCargoå’ŒCrates.io</h3>
<ul>
<li>é€šè¿‡å‘å¸ƒé…ç½®æ–‡ä»¶è‡ªå®šä¹‰æ‚¨çš„æ„å»º</li>
<li>åœ¨crates.ioä¸Šå‘å¸ƒåº“</li>
<li>ä½¿ç”¨å·¥ä½œåŒºç»„ç»‡å¤§å‹é¡¹ç›®</li>
<li>ä»crates.ioå®‰è£…äºŒè¿›åˆ¶æ–‡ä»¶</li>
<li>ä½¿ç”¨è‡ªå®šä¹‰å‘½ä»¤æ‰©å±• Cargo</li>
</ul>
<h4 id="171-ä½¿ç”¨å‘å¸ƒé…ç½®æ–‡ä»¶è‡ªå®šä¹‰æ„å»º">17.1 ä½¿ç”¨å‘å¸ƒé…ç½®æ–‡ä»¶è‡ªå®šä¹‰æ„å»º</h4>
<p>Cargo æœ‰ä¸¤ä¸ªä¸»è¦é…ç½®æ–‡ä»¶ï¼šdevCargo åœ¨æ‚¨è¿è¡Œæ—¶ä½¿ç”¨cargo buildçš„releaseé…ç½®æ–‡ä»¶å’ŒCargo åœ¨æ‚¨è¿è¡Œæ—¶ä½¿ç”¨çš„é…ç½®æ–‡ä»¶cargo build &ndash;releaseã€‚è¯¥devé…ç½®æ–‡ä»¶ä¸ºå¼€å‘å®šä¹‰äº†è‰¯å¥½çš„é»˜è®¤å€¼ï¼Œå¹¶ä¸”è¯¥releaseé…ç½®æ–‡ä»¶å…·æœ‰ç”¨äºå‘å¸ƒæ„å»ºçš„è‰¯å¥½é»˜è®¤å€¼ã€‚</p>
<pre tabindex="0"><code>$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
$ cargo build --release
    Finished release [optimized] target(s) in 0.0s
</code></pre><p>æ­¤æ„å»ºè¾“å‡ºä¸­æ˜¾ç¤ºçš„devå’Œreleaseè¡¨æ˜ç¼–è¯‘å™¨æ­£åœ¨ä½¿ç”¨ä¸åŒçš„é…ç½®æ–‡ä»¶ã€‚</p>
<p>æ–‡ä»¶åï¼šCargo.toml</p>
<pre tabindex="0"><code>[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre><p>è¯¥opt-levelè®¾ç½®æ§åˆ¶ Rust å°†åº”ç”¨äºæ‚¨çš„ä»£ç çš„ä¼˜åŒ–æ•°é‡ï¼ŒèŒƒå›´ä¸º 0 åˆ° 3ã€‚åº”ç”¨æ›´å¤šä¼˜åŒ–ä¼šå»¶é•¿ç¼–è¯‘æ—¶é—´ï¼Œå› æ­¤å¦‚æœæ‚¨æ­£åœ¨å¼€å‘å¹¶ç»å¸¸ç¼–è¯‘æ‚¨çš„ä»£ç ï¼Œæ‚¨å°†éœ€è¦æ›´å¿«çš„ç¼–è¯‘ï¼Œå³ä½¿ç”Ÿæˆçš„ä»£ç è¿è¡Œé€Ÿåº¦è¾ƒæ…¢ã€‚è¿™å°±æ˜¯åŸå› ï¼Œé»˜è®¤opt-levelçš„devå°±æ˜¯0ã€‚å½“æ‚¨å‡†å¤‡å¥½å‘å¸ƒä»£ç æ—¶ï¼Œæœ€å¥½èŠ±æ›´å¤šæ—¶é—´ç¼–è¯‘ã€‚æ‚¨åªä¼šåœ¨å‘å¸ƒæ¨¡å¼ä¸‹ç¼–è¯‘ä¸€æ¬¡ï¼Œä½†æ‚¨å°†å¤šæ¬¡è¿è¡Œå·²ç¼–è¯‘çš„ç¨‹åºï¼Œå› æ­¤å‘å¸ƒæ¨¡å¼ä¼šç”¨æ›´é•¿çš„ç¼–è¯‘æ—¶é—´æ¥æ¢å–è¿è¡Œé€Ÿåº¦æ›´å¿«çš„ä»£ç ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆé»˜è®¤opt-levelçš„releaseé…ç½®æ–‡ä»¶3ã€‚</p>
<p>æ–‡ä»¶åï¼šCargo.toml</p>
<pre tabindex="0"><code>[profile.dev]
opt-level = 1
</code></pre><p>æ­¤ä»£ç è¦†ç›– çš„é»˜è®¤è®¾ç½®0ã€‚ç°åœ¨ï¼Œå½“æˆ‘ä»¬è¿è¡Œæ—¶cargo buildï¼ŒCargo å°†ä½¿ç”¨devé…ç½®æ–‡ä»¶çš„é»˜è®¤å€¼åŠ ä¸Šæˆ‘ä»¬å¯¹ opt-level. å› ä¸ºæˆ‘ä»¬è®¾ç½®opt-levelä¸º1ï¼ŒCargo å°†åº”ç”¨æ¯”é»˜è®¤æ›´å¤šçš„ä¼˜åŒ–ï¼Œä½†ä¸ä¼šåƒåœ¨å‘å¸ƒç‰ˆæœ¬ä¸­é‚£ä¹ˆå¤šã€‚</p>
<h4 id="172-å°†-crate-å‘å¸ƒåˆ°-cratesio">17.2 å°† Crate å‘å¸ƒåˆ° Crates.io</h4>
<ul>
<li>
<ol>
<li>è¿›è¡Œæœ‰ç”¨çš„æ–‡æ¡£è¯„è®º</li>
</ol>
</li>
</ul>
<p>æ–‡æ¡£æ³¨é‡Šä½¿ç”¨ä¸‰ä¸ªæ–œæ  ,///è€Œä¸æ˜¯ä¸¤ä¸ªï¼Œå¹¶ä¸”æ”¯æŒ Markdown è¡¨ç¤ºæ³•æ¥æ ¼å¼åŒ–æ–‡æœ¬ã€‚å°†æ–‡æ¡£æ³¨é‡Šæ”¾åœ¨ä»–ä»¬æ­£åœ¨è®°å½•çš„é¡¹ç›®ä¹‹å‰ã€‚</p>
<p>å‡½æ•°æ–‡æ¡£æ³¨é‡Šä¾‹å­ï¼š</p>
<pre tabindex="0"><code>/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre><ul>
<li>
<ol start="2">
<li>è®¾ç½® Crates.io å¸æˆ·</li>
</ol>
</li>
</ul>
<p>åœ¨å‘å¸ƒä»»ä½• crate ä¹‹å‰ï¼Œæ‚¨éœ€è¦åœ¨crates.ioä¸Šåˆ›å»ºä¸€ä¸ªå¸æˆ· å¹¶è·å– API ä»¤ç‰Œã€‚ä¸ºæ­¤ï¼Œè¯·è®¿é—®crates.io çš„ä¸»é¡µå¹¶é€šè¿‡ GitHub å¸æˆ·ç™»å½•ã€‚ï¼ˆGitHub å¸æˆ·ç›®å‰æ˜¯å¿…éœ€çš„ï¼Œä½†è¯¥ç«™ç‚¹å°†æ¥å¯èƒ½ä¼šæ”¯æŒå…¶ä»–åˆ›å»ºå¸æˆ·çš„æ–¹å¼ã€‚ï¼‰ç™»å½•åï¼Œè¯·è®¿é—®https://crates.io/me/ ä¸Šçš„å¸æˆ·è®¾ç½®å¹¶æ£€ç´¢æ‚¨çš„å¸æˆ· API å¯†é’¥ã€‚ç„¶åcargo loginä½¿ç”¨æ‚¨çš„ API å¯†é’¥è¿è¡Œå‘½ä»¤ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<pre tabindex="0"><code>$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre><ul>
<li>3 å°†å…ƒæ•°æ®æ·»åŠ åˆ°æ–°çš„ Crate</li>
</ul>
<p>æ–‡ä»¶åï¼šCargo.toml</p>
<pre tabindex="0"><code>[package]
name = &#34;guessing_game&#34;
version = &#34;0.1.0&#34;
authors = [&#34;Your Name &lt;you@example.com&gt;&#34;]
edition = &#34;2018&#34;
description = &#34;A fun game where you guess what number the computer has chosen.&#34;
license = &#34;MIT OR Apache-2.0&#34;
</code></pre><pre tabindex="0"><code>$ cargo publish
</code></pre><ul>
<li>
<ol start="4">
<li>å‘å¸ƒåˆ° Crates.io</li>
</ol>
</li>
</ul>
<p>cargo publishå†æ¬¡è¿è¡Œå‘½ä»¤ã€‚ç°åœ¨åº”è¯¥æˆåŠŸäº†ï¼š</p>
<pre tabindex="0"><code>$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre><ul>
<li>
<ol start="5">
<li>ä» Crates.io ä¸­åˆ é™¤ç‰ˆæœ¬ cargo yank</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>$ cargo yank --vers 1.0.1
</code></pre><pre tabindex="0"><code>$ cargo yank --vers 1.0.1 --undo
</code></pre><h4 id="173-cargoå·¥ä½œåŒºåŸŸ">17.3 Cargoå·¥ä½œåŒºåŸŸ</h4>
<ul>
<li>
<ol>
<li>åˆ›å»ºå·¥ä½œåŒºåŸŸ</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>$ mkdir add
$ cd add
</code></pre><pre tabindex="0"><code>[workspace]

members = [
    &#34;adder&#34;,
]
</code></pre><pre tabindex="0"><code>$ cargo new adder
     Created binary (application) `adder` package     
</code></pre><p>æ‰§è¡Œcargo builhåçš„æ–‡ä»¶ç›®å½•å¦‚ä¸‹ï¼š</p>
<pre tabindex="0"><code>â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ adder
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src
â”‚       â””â”€â”€ main.rs
â””â”€â”€ target
</code></pre><ul>
<li>
<ol start="2">
<li>åœ¨å·¥ä½œåŒºåŸŸä¸­åˆ›å»ºç¬¬äºŒä¸ªåŒ…</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>[workspace]

members = [
    &#34;adder&#34;,
    &#34;add-one&#34;,
]
</code></pre><pre tabindex="0"><code>$ cargo new add-one --lib
     Created library `add-one` package
</code></pre><pre tabindex="0"><code>â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ add-one
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src
â”‚       â””â”€â”€ lib.rs
â”œâ”€â”€ adder
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src
â”‚       â””â”€â”€ main.rs
â””â”€â”€ target
</code></pre><ul>
<li>
<ol start="3">
<li>åœ¨å·¥ä½œåŒºåŸŸä¸­æ·»åŠ ä¾èµ–åŒ…</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>[dependencies]
rand = &#34;0.8.3&#34;
</code></pre><ul>
<li>
<ol start="4">
<li>åœ¨å·¥ä½œåŒºåŸŸä¸­æ·»åŠ æµ‹è¯•</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
</code></pre><h4 id="174-ä»-cratesio-å®‰è£…äºŒè¿›åˆ¶æ–‡ä»¶-cargo-install">17.4 ä» Crates.io å®‰è£…äºŒè¿›åˆ¶æ–‡ä»¶ cargo install</h4>
<p>è¯¥cargo installå‘½ä»¤å…è®¸æ‚¨åœ¨æœ¬åœ°å®‰è£…å’Œä½¿ç”¨äºŒè¿›åˆ¶åŒ…ã€‚å®‰è£…çš„æ‰€æœ‰äºŒè¿›åˆ¶æ–‡ä»¶cargo installéƒ½å­˜å‚¨åœ¨å®‰è£…æ ¹ç›®å½•çš„binæ–‡ä»¶å¤¹ä¸­ã€‚</p>
<pre tabindex="0"><code>$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v11.0.2
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v11.0.2
--snip--
   Compiling ripgrep v11.0.2
    Finished release [optimized + debuginfo] target(s) in 3m 10s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v11.0.2` (executable `rg`)
</code></pre><h4 id="175-ä½¿ç”¨è‡ªå®šä¹‰å‘½ä»¤æ‰©å±•-cargo">17.5 ä½¿ç”¨è‡ªå®šä¹‰å‘½ä»¤æ‰©å±• Cargo</h4>
<pre tabindex="0"><code>cargo --list
</code></pre><h3 id="18-æ™ºèƒ½æŒ‡é’ˆ">18. æ™ºèƒ½æŒ‡é’ˆ</h3>
<h4 id="181-ä½¿ç”¨btæŒ‡å‘å †æ ˆæ•°æ®">18.1 ä½¿ç”¨B<!-- raw HTML omitted -->æŒ‡å‘å †æ ˆæ•°æ®</h4>
<pre tabindex="0"><code>fn main() {
    let b = Box::new(5);
    println!(&#34;b = {}&#34;, b);
}
</code></pre><h4 id="182-å°†æ™ºèƒ½æŒ‡é’ˆè§†ä¸ºå…·æœ‰dereftrait-çš„å¸¸è§„å¼•ç”¨">18.2 å°†æ™ºèƒ½æŒ‡é’ˆè§†ä¸ºå…·æœ‰Dereftrait çš„å¸¸è§„å¼•ç”¨</h4>
<pre tabindex="0"><code>fn main() {
    let m = MyBox::new(String::from(&#34;Rust&#34;));
    hello(&amp;m);
}
</code></pre><h4 id="183-ä½¿ç”¨dropç‰¹å¾åœ¨æ¸…ç†æ—¶è¿è¡Œä»£ç ">18.3 ä½¿ç”¨Dropç‰¹å¾åœ¨æ¸…ç†æ—¶è¿è¡Œä»£ç </h4>
<pre tabindex="0"><code>struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!(&#34;Dropping CustomSmartPointer with data `{}`!&#34;, self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from(&#34;my stuff&#34;),
    };
    let d = CustomSmartPointer {
        data: String::from(&#34;other stuff&#34;),
    };
    println!(&#34;CustomSmartPointers created.&#34;);
}
</code></pre><p>å°½æ—©åˆ é™¤ä¸€ä¸ªå€¼ std::mem::dropã€‚</p>
<pre tabindex="0"><code>fn main() {
    let c = CustomSmartPointer {
        data: String::from(&#34;some data&#34;),
    };
    println!(&#34;CustomSmartPointer created.&#34;);
    drop(c);
    println!(&#34;CustomSmartPointer dropped before the end of main.&#34;);
}
</code></pre><h4 id="184-ä½¿ç”¨rtè¿›è¡Œæ™ºèƒ½æŒ‡é’ˆè®¡æ•°">18.4 ä½¿ç”¨R<!-- raw HTML omitted -->è¿›è¡Œæ™ºèƒ½æŒ‡é’ˆè®¡æ•°</h4>
<pre tabindex="0"><code>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&#34;count after creating a = {}&#34;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!(&#34;count after creating b = {}&#34;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!(&#34;count after creating c = {}&#34;, Rc::strong_count(&amp;a));
    }
    println!(&#34;count after c goes out of scope = {}&#34;, Rc::strong_count(&amp;a));
}
</code></pre><h4 id="185-refcellt-å’Œå†…éƒ¨å¯å˜æ€§æ¨¡å¼">18.5 RefCell<!-- raw HTML omitted --> å’Œå†…éƒ¨å¯å˜æ€§æ¨¡å¼</h4>
<pre tabindex="0"><code>#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!(&#34;a after = {:?}&#34;, a);
    println!(&#34;b after = {:?}&#34;, b);
    println!(&#34;c after = {:?}&#34;, c);
}
</code></pre><h4 id="186-å¼•ç”¨å¯å¼•å‘å†…å­˜æº¢å‡º">18.6 å¼•ç”¨å¯å¼•å‘å†…å­˜æº¢å‡º</h4>
<pre tabindex="0"><code>n main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        &#34;leaf strong = {}, weak = {}&#34;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            &#34;branch strong = {}, weak = {}&#34;,
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            &#34;leaf strong = {}, weak = {}&#34;,
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!(&#34;leaf parent = {:?}&#34;, leaf.parent.borrow().upgrade());
    println!(
        &#34;leaf strong = {}, weak = {}&#34;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}
</code></pre><h3 id="19-å¹¶å‘">19. å¹¶å‘</h3>
<ul>
<li>å¦‚ä½•åˆ›å»ºçº¿ç¨‹åŒæ—¶è¿è¡Œå¤šæ®µä»£ç </li>
<li>æ¶ˆæ¯ä¼ é€’å¹¶å‘ï¼Œå…¶ä¸­é€šé“åœ¨çº¿ç¨‹ä¹‹é—´å‘é€æ¶ˆæ¯</li>
<li>å…±äº«çŠ¶æ€å¹¶å‘ï¼Œå…¶ä¸­å¤šä¸ªçº¿ç¨‹å¯ä»¥è®¿é—®æŸäº›æ•°æ®</li>
<li>Syncå’ŒSendç‰¹å¾ï¼Œå»¶ä¼¸Rustçš„å¹¶å‘ä¿è¯ç”±æ ‡å‡†åº“æä¾›çš„ç”¨æˆ·å®šä¹‰çš„ç±»å‹ä»¥åŠç±»å‹</li>
</ul>
<h4 id="191-ä½¿ç”¨çº¿ç¨‹è¿è¡Œä»£ç ">19.1 ä½¿ç”¨çº¿ç¨‹è¿è¡Œä»£ç </h4>
<ul>
<li>1.ä½¿ç”¨spawnåˆ›å»ºçº¿ç¨‹</li>
</ul>
<pre tabindex="0"><code>use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&#34;hi number {} from the spawned thread!&#34;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&#34;hi number {} from the main thread!&#34;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre><ul>
<li>2.ç­‰å¾…çº¿ç¨‹ç»“æŸä½¿ç”¨joinå¥æŸ„</li>
</ul>
<pre tabindex="0"><code>use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&#34;hi number {} from the spawned thread!&#34;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&#34;hi number {} from the main thread!&#34;, i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
</code></pre><p>å¦‚æœå°†æ‰§è¡Œè¯­å¥æ”¹å˜ï¼Œç»“æœä¹Ÿå°†å‘ç”Ÿæ”¹å˜ï¼š</p>
<pre tabindex="0"><code>use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&#34;hi number {} from the spawned thread!&#34;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!(&#34;hi number {} from the main thread!&#34;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre><ul>
<li>
<ol start="3">
<li>åœ¨çº¿ç¨‹ä¸­ä½¿ç”¨move</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&#34;Here&#39;s a vector: {:?}&#34;, v);
    });

    handle.join().unwrap();
}
</code></pre><h4 id="192-çº¿ç¨‹ç›´æ¥ä¼ é€’æ•°æ®">19.2 çº¿ç¨‹ç›´æ¥ä¼ é€’æ•°æ®</h4>
<pre tabindex="0"><code>use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&#34;hi&#34;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!(&#34;Got: {}&#34;, received);
}
</code></pre><p>ç®¡é“å’Œæ‰€æœ‰æƒè½¬ç§»</p>
<pre tabindex="0"><code>use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from(&#34;hi&#34;),
            String::from(&#34;from&#34;),
            String::from(&#34;the&#34;),
            String::from(&#34;thread&#34;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&#34;Got: {}&#34;, received);
    }
}
</code></pre><h4 id="193-å…±äº«çŠ¶æ€å¹¶å‘">19.3 å…±äº«çŠ¶æ€å¹¶å‘</h4>
<pre tabindex="0"><code>use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&#34;Result: {}&#34;, *counter.lock().unwrap());
}
</code></pre><h4 id="194-å…·æœ‰syncå’Œsendç‰¹å¾çš„å¯æ‰©å±•å¹¶å‘">19.4 å…·æœ‰Syncå’ŒSendç‰¹å¾çš„å¯æ‰©å±•å¹¶å‘</h4>
<p>æ‰€è¿°Sendæ ‡è®°ç‰©æ€§çŠ¶è¡¨ç¤ºå®æ–½ç±»å‹çš„å€¼çš„æ‰€æœ‰æƒ Sendå¯ä»¥åœ¨çº¿ç¨‹ä¹‹é—´è½¬ç§»ã€‚å‡ ä¹æ‰€æœ‰çš„ Rust ç±»å‹éƒ½æ˜¯Sendï¼Œä½†ä¹Ÿæœ‰ä¸€äº›ä¾‹å¤–ï¼ŒåŒ…æ‹¬Rc<!-- raw HTML omitted -->ï¼šè¿™ä¸å¯èƒ½æ˜¯Sendå› ä¸ºå¦‚æœä½ å…‹éš†äº†ä¸€ä¸ªRc<!-- raw HTML omitted -->å€¼å¹¶è¯•å›¾å°†å…‹éš†çš„æ‰€æœ‰æƒè½¬ç§»åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ï¼Œä¸¤ä¸ªçº¿ç¨‹å¯èƒ½ä¼šåŒæ—¶æ›´æ–°å¼•ç”¨è®¡æ•°ã€‚å‡ºäºè¿™ä¸ªåŸå› ï¼ŒRc<!-- raw HTML omitted -->å®ç°ç”¨äºå•çº¿ç¨‹æƒ…å†µï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‚¨ä¸æƒ³æ”¯ä»˜çº¿ç¨‹å®‰å…¨çš„æ€§èƒ½æŸå¤±ã€‚</p>
<h3 id="20-rustçš„é¢å‘å¯¹è±¡ç‰¹æ€§">20. Rustçš„é¢å‘å¯¹è±¡ç‰¹æ€§</h3>
<p>å°†å±•ç¤ºå¦‚ä½•åœ¨ Rust ä¸­å®ç°é¢å‘å¯¹è±¡çš„è®¾è®¡æ¨¡å¼ï¼Œå¹¶è®¨è®ºè¿™æ ·åšä¸ä½¿ç”¨ Rust çš„ä¸€äº›ä¼˜åŠ¿æ¥å®ç°è§£å†³æ–¹æ¡ˆä¹‹é—´çš„æƒè¡¡ã€‚</p>
<h4 id="201-é¢å‘å¯¹è±¡è¯­è¨€ç‰¹ç‚¹">20.1 é¢å‘å¯¹è±¡è¯­è¨€ç‰¹ç‚¹</h4>
<pre tabindex="0"><code>pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}

impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            }
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
</code></pre><h4 id="202-ä½¿ç”¨å…è®¸ä¸åŒç±»å‹å€¼çš„ç‰¹å¾å¯¹è±¡">20.2 ä½¿ç”¨å…è®¸ä¸åŒç±»å‹å€¼çš„ç‰¹å¾å¯¹è±¡</h4>
<pre tabindex="0"><code>pub trait Draw {
    fn draw(&amp;self);
}
</code></pre><pre tabindex="0"><code>pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}
</code></pre><pre tabindex="0"><code>impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
</code></pre><pre tabindex="0"><code>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
where
    T: Draw,
{
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
</code></pre><pre tabindex="0"><code>pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // code to actually draw a button
    }
}
</code></pre><pre tabindex="0"><code>use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // code to actually draw a select box
    }
}
</code></pre><pre tabindex="0"><code>use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from(&#34;Yes&#34;),
                    String::from(&#34;Maybe&#34;),
                    String::from(&#34;No&#34;),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from(&#34;OK&#34;),
            }),
        ],
    };

    screen.run();
}
</code></pre><h4 id="203-å®ç°é¢å‘å¯¹è±¡è®¾è®¡">20.3 å®ç°é¢å‘å¯¹è±¡è®¾è®¡</h4>
<pre tabindex="0"><code>pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
</code></pre><h3 id="21-æ¨¡å¼å’ŒåŒ¹é…">21. æ¨¡å¼å’ŒåŒ¹é…</h3>
<ul>
<li>Literals</li>
<li>Destructured arrays, enums, structs, or tuples</li>
<li>Variables</li>
<li>Wildcards</li>
<li>Placeholders</li>
</ul>
<h4 id="211-æ‰€æœ‰çš„åœ°æ–¹æ¨¡å¼éƒ½å¯ä»¥ä½¿ç”¨">21.1 æ‰€æœ‰çš„åœ°æ–¹æ¨¡å¼éƒ½å¯ä»¥ä½¿ç”¨</h4>
<ul>
<li>
<ol>
<li>match</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre><ul>
<li>
<ol start="2">
<li>æ¡ä»¶if letè¡¨è¾¾å¼</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = &#34;34&#34;.parse();

    if let Some(color) = favorite_color {
        println!(&#34;Using your favorite color, {}, as the background&#34;, color);
    } else if is_tuesday {
        println!(&#34;Tuesday is green day!&#34;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!(&#34;Using purple as the background color&#34;);
        } else {
            println!(&#34;Using orange as the background color&#34;);
        }
    } else {
        println!(&#34;Using blue as the background color&#34;);
    }
}
</code></pre><ul>
<li>
<ol start="3">
<li>while let æ¡ä»¶å¾ªç¯</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(top) = stack.pop() {
        println!(&#34;{}&#34;, top);
    }
</code></pre><ul>
<li>
<ol start="4">
<li>for å¾ªç¯</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>    let v = vec![&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];

    for (index, value) in v.iter().enumerate() {
        println!(&#34;{} is at index {}&#34;, value, index);
    }
</code></pre><ul>
<li>
<ol start="5">
<li>let å£°æ˜</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>let x = 5;
</code></pre><pre tabindex="0"><code>let PATTERN = EXPRESSION;
</code></pre><pre tabindex="0"><code>let (x, y, z) = (1, 2, 3);
</code></pre><ul>
<li>
<ol start="6">
<li>åŠŸèƒ½å‚æ•°</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>fn foo(x: i32) {
    // code goes here
}
</code></pre><h4 id="212-åŒ¹é…å’Œä¸åŒ¹é…">21.2 åŒ¹é…å’Œä¸åŒ¹é…</h4>
<pre tabindex="0"><code>if let Some(x) = some_option_value {
        println!(&#34;{}&#34;, x);
    }
</code></pre><pre tabindex="0"><code>if let x = 5 {
        println!(&#34;{}&#34;, x);
    };
</code></pre><h4 id="203-æ¨¡å¼è¯­æ³•">20.3 æ¨¡å¼è¯­æ³•</h4>
<ul>
<li>
<ol>
<li>åŒ¹é…æ–‡å­—</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code> let x = 1;

    match x {
        1 =&gt; println!(&#34;one&#34;),
        2 =&gt; println!(&#34;two&#34;),
        3 =&gt; println!(&#34;three&#34;),
        _ =&gt; println!(&#34;anything&#34;),
    }
</code></pre><ul>
<li>
<ol start="2">
<li>åŒ¹é…å‘½åå˜é‡</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&#34;Got 50&#34;),
        Some(y) =&gt; println!(&#34;Matched, y = {:?}&#34;, y),
        _ =&gt; println!(&#34;Default case, x = {:?}&#34;, x),
    }

    println!(&#34;at the end: x = {:?}, y = {:?}&#34;, x, y);
</code></pre><ul>
<li>
<ol start="3">
<li>å¤šç§æ¨¡å¼</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>let x = 1;

    match x {
        1 | 2 =&gt; println!(&#34;one or two&#34;),
        3 =&gt; println!(&#34;three&#34;),
        _ =&gt; println!(&#34;anything&#34;),
    }
</code></pre><ul>
<li>
<ol start="4">
<li>åŒ¹é…å€¼çš„èŒƒå›´ ..=</li>
</ol>
</li>
</ul>
<p>æ•°å­—ï¼š</p>
<pre tabindex="0"><code>    let x = 5;

    match x {
        1..=5 =&gt; println!(&#34;one through five&#34;),
        _ =&gt; println!(&#34;something else&#34;),
    }
</code></pre><p>å­—ç¬¦ï¼š</p>
<pre tabindex="0"><code>    let x = &#39;c&#39;;

    match x {
        &#39;a&#39;..=&#39;j&#39; =&gt; println!(&#34;early ASCII letter&#34;),
        &#39;k&#39;..=&#39;z&#39; =&gt; println!(&#34;late ASCII letter&#34;),
        _ =&gt; println!(&#34;something else&#34;),
    }
</code></pre><ul>
<li>
<ol start="5">
<li>è§£æ„ä»¥æ‰“ç ´ä»·å€¼è§‚</li>
</ol>
</li>
</ul>
<p>è§£æ„ç»“æ„:</p>
<pre tabindex="0"><code>struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);

    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&#34;On the x axis at {}&#34;, x),
        Point { x: 0, y } =&gt; println!(&#34;On the y axis at {}&#34;, y),
        Point { x, y } =&gt; println!(&#34;On neither axis: ({}, {})&#34;, x, y),
    }
}
</code></pre><p>è§£æ„æšä¸¾:</p>
<pre tabindex="0"><code>enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!(&#34;The Quit variant has no data to destructure.&#34;)
        }
        Message::Move { x, y } =&gt; {
            println!(
                &#34;Move in the x direction {} and in the y direction {}&#34;,
                x, y
            );
        }
        Message::Write(text) =&gt; println!(&#34;Text message: {}&#34;, text),
        Message::ChangeColor(r, g, b) =&gt; println!(
            &#34;Change the color to red {}, green {}, and blue {}&#34;,
            r, g, b
        ),
    }
}
</code></pre><p>è§£æ„åµŒå¥—ç»“æ„å’Œæšä¸¾:</p>
<pre tabindex="0"><code>enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; println!(
            &#34;Change the color to red {}, green {}, and blue {}&#34;,
            r, g, b
        ),
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; println!(
            &#34;Change the color to hue {}, saturation {}, and value {}&#34;,
            h, s, v
        ),
        _ =&gt; (),
    }
}
</code></pre><p>è§£æ„ç»“æ„å’Œå…ƒç»„:</p>
<pre tabindex="0"><code> let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
</code></pre><ul>
<li>
<ol start="6">
<li>å¿½ç•¥æ¨¡å¼ä¸­çš„å€¼</li>
</ol>
</li>
</ul>
<p>å¿½ç•¥æ•´ä¸ªå€¼ _</p>
<pre tabindex="0"><code>fn foo(_: i32, y: i32) {
    println!(&#34;This code only uses the y parameter: {}&#34;, y);
}

fn main() {
    foo(3, 4);
}
</code></pre><p>ä½¿ç”¨åµŒå¥—å¿½ç•¥éƒ¨åˆ†å€¼ _</p>
<pre tabindex="0"><code>let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!(&#34;Can&#39;t overwrite an existing customized value&#34;);
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!(&#34;setting is {:?}&#34;, setting_value);
</code></pre><pre tabindex="0"><code>let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!(&#34;Some numbers: {}, {}, {}&#34;, first, third, fifth)
        }
    }
</code></pre><p>å¿½ç•¥ä¸€ä¸ªæœªä½¿ç”¨çš„å˜é‡ï¼Œä»¥å®ƒçš„åå­—å¼€å¤´ _</p>
<pre tabindex="0"><code>fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre><p>å¿½ç•¥å€¼çš„å‰©ä½™éƒ¨åˆ† ..</p>
<pre tabindex="0"><code>struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!(&#34;x is {}&#34;, x),
    }
</code></pre><p>å¦‚ä½•ä½¿ç”¨..å…ƒç»„</p>
<pre tabindex="0"><code>fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&#34;Some numbers: {}, {}&#34;, first, last);
        }
    }
}
</code></pre><p>è¯•å›¾ä»¥..ä¸€ç§æ¨¡æ£±ä¸¤å¯çš„æ–¹å¼ä½¿ç”¨çš„é”™è¯¯ä½¿ç”¨ï¼š</p>
<pre tabindex="0"><code>fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&#34;Some numbers: {}&#34;, second)
        },
    }
}
</code></pre><p>å¸¦æœ‰åŒ¹é…å®ˆå«çš„é¢å¤–æ¡ä»¶</p>
<pre tabindex="0"><code>    let num = Some(4);

    match num {
        Some(x) if x &lt; 5 =&gt; println!(&#34;less than five: {}&#34;, x),
        Some(x) =&gt; println!(&#34;{}&#34;, x),
        None =&gt; (),
    }
</code></pre><p>@ ç»‘å®š</p>
<pre tabindex="0"><code> enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!(&#34;Found an id in range: {}&#34;, id_variable),
        Message::Hello { id: 10..=12 } =&gt; {
            println!(&#34;Found an id in another range&#34;)
        }
        Message::Hello { id } =&gt; println!(&#34;Found some other id: {}&#34;, id),
    }
</code></pre><h3 id="22-é«˜çº§åŠŸèƒ½">22 é«˜çº§åŠŸèƒ½</h3>
<ul>
<li>ä¸å®‰å…¨çš„Rust</li>
<li>é«˜çº§ç‰¹æ€§</li>
<li>é«˜çº§ç±»å‹</li>
<li>é«˜çº§å‡½æ•°å’Œé—­åŒ…</li>
<li>å®æŒ‡ä»¤</li>
</ul>
<h4 id="221-ä¸å®‰å…¨çš„rust">22.1 ä¸å®‰å…¨çš„Rust</h4>
<pre tabindex="0"><code>unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}

fn main() {}
</code></pre><h4 id="222-é«˜çº§ç‰¹æ€§">22.2 é«˜çº§ç‰¹æ€§</h4>
<pre tabindex="0"><code>use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &#34;[{}]&#34;, self.0.join(&#34;, &#34;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&#34;hello&#34;), String::from(&#34;world&#34;)]);
    println!(&#34;w = {}&#34;, w);
}
</code></pre><h4 id="223-é«˜çº§ç±»å‹">22.3 é«˜çº§ç±»å‹</h4>
<ul>
<li>
<ol>
<li>åˆ›å»ºåŒ¿åç±»å‹</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!(&#34;x + y = {}&#34;, x + y);
</code></pre><ul>
<li>
<ol start="2">
<li>ä»æœªä½¿ç”¨ç±»å‹å’Œè¿”å›å€¼</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&#34;called `Option::unwrap()` on a `None` value&#34;),
        }
    }
}
</code></pre><h4 id="224-é«˜çº§å‡½æ•°å’Œé—­åŒ…">22.4 é«˜çº§å‡½æ•°å’Œé—­åŒ…</h4>
<pre tabindex="0"><code>fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!(&#34;The answer is: {}&#34;, answer);
}
</code></pre><pre tabindex="0"><code>fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
</code></pre><h4 id="225-å®æŒ‡ä»¤">22.5 å®æŒ‡ä»¤</h4>
<p>å±•ç¤ºä¸€ä¸ªç®€å•çš„å®šä¹‰vec!å®</p>
<pre tabindex="0"><code>#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
</code></pre><h3 id="23-æœ€ç»ˆçš„é¡¹ç›®åˆ›å»ºä¸€ä¸ªå¤šçº¿ç¨‹çš„webæœåŠ¡">23 æœ€ç»ˆçš„é¡¹ç›®ï¼šåˆ›å»ºä¸€ä¸ªå¤šçº¿ç¨‹çš„WebæœåŠ¡</h3>
<ul>
<li>
<p>å­¦ä¹ ä¸€ç‚¹TCPå’ŒHTTP</p>
</li>
<li>
<p>TCPçš„Stocketç›‘å¬</p>
</li>
<li>
<p>åœ¨HTTPè¯·æ±‚ä¸­å¤„ç†ä¸€ä¸ªæ•°å­—</p>
</li>
<li>
<p>åˆ›å»ºä¸€ä¸ªHTTPåé¦ˆ</p>
</li>
<li>
<p>æ”¹è¿›WebæœåŠ¡æä¾›çº¿ç¨‹æ± åŠŸèƒ½</p>
</li>
</ul>
<h4 id="231-åˆ›å»ºä¸€ä¸ªå•çº¿ç¨‹çš„webæœåŠ¡">23.1 åˆ›å»ºä¸€ä¸ªå•çº¿ç¨‹çš„WebæœåŠ¡</h4>
<pre tabindex="0"><code>use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&#34;127.0.0.1:7878&#34;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!(&#34;Connection established!&#34;);
    }
}
</code></pre><h4 id="232-å°†å•çº¿ç¨‹è½¬å˜ä¸ºå¤šçº¿ç¨‹">23.2 å°†å•çº¿ç¨‹è½¬å˜ä¸ºå¤šçº¿ç¨‹</h4>
<pre tabindex="0"><code>
use std::thread;
use std::time::Duration;
// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--

    let get = b&#34;GET / HTTP/1.1\r\n&#34;;
    let sleep = b&#34;GET /sleep HTTP/1.1\r\n&#34;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&#34;HTTP/1.1 200 OK&#34;, &#34;hello.html&#34;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&#34;HTTP/1.1 200 OK&#34;, &#34;hello.html&#34;)
    } else {
        (&#34;HTTP/1.1 404 NOT FOUND&#34;, &#34;404.html&#34;)
    };

    // --snip--
}
</code></pre><p>åˆ›å»ºçº¿ç¨‹æ± å¯¹è±¡ï¼š</p>
<pre tabindex="0"><code>use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --snip--
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}
</code></pre><h4 id="233-è·Ÿè¸ªå’Œæ¸…ç†å·¥ä½œ">23.3 è·Ÿè¸ªå’Œæ¸…ç†å·¥ä½œ</h4>
<pre tabindex="0"><code>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre><p>æ¸…ç†ï¼š</p>
<pre tabindex="0"><code>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&#34;Shutting down worker {}&#34;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</code></pre><p>çœ‹å®Œäº†ï¼Œä½†æ˜¯çœŸæ­£çš„ä½¿ç”¨ä¸Šï¼Œæ„Ÿè§‰è¿˜éœ€è¦ä¸€æ®µæ—¶é—´å‘€ï¼</p>
<blockquote>
<p>è·¯æ¼«æ¼«åŠå…¶ä¿®è¿œï¼Œå¾å°†ä¸Šä¸‹è€Œæ±‚ç´¢ã€‚</p>
</blockquote>
<p>2021å¹´06æœˆ15æ—¥</p>

            </div>
        </div>
    </div>
</section>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-123-45', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>
    
  
  <script type="text/javascript">
    hljs.initHighlightingOnLoad();
  </script>





</body>
</html>

